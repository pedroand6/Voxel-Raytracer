#version 450 core
 
#define LEAF_FLAG 255u 
#define INTERNAL_NODE_FLAG 0u

// A dimensão da sua folha em texels (baseado no seu C++)
#define LEAF_SIZE 3

const int MAX_RAYS = 8;
const vec4 skyColor = vec4(0.5, 0.7, 1.0, 1.0);

layout (local_size_x = 8, local_size_y = 8, local_size_z = 1) in;
layout (rgba8, binding = 0) uniform writeonly image2D destTex;

layout (std140, binding = 1) uniform Camera {
    mat4 invProjection;
    mat4 invView;
    vec4 cameraPos;
};

layout (binding = 2) uniform usampler3D u_octreeTexture;

// A dimensão da sua textura (ex: 256.0 para uma textura 256x256x256)
uniform int u_texDim;

// Os cantos min/max do volume total da sua octree no espaço do mundo
uniform ivec3 u_worldBoundsMin;
uniform ivec3 u_worldBoundsMax;
ivec3 worldSize = u_worldBoundsMax - u_worldBoundsMin;

uniform vec4 globalLight;
uniform vec3 lightDir;

/*
 * Estrutura de Retorno
 * Contém os dados do voxel que encontramos.
 */
struct VoxelData {
    lowp vec4 color;       // Cor (RGBA)
    lowp vec3 properties;  // Refração, Iluminação, K
    mediump ivec3 nodeMin;
    mediump ivec3 nodeMax;
};

/*
 * Estrutura de Raio
 * Usada para rastreamento de raios.
 */
struct Ray {
    mediump vec3 origin;
    mediump vec3 direction;
    mediump float IOF;
    mediump float weight;
    bool defined;
    lowp vec4 colorTint;
    mediump float distanceInMedium;
    lowp vec4 mediumColor;
    lowp float mediumDensity;
};

/*
 * Funções Auxiliares
 */

// Converte uma coordenada 3D em um índice linear 1D
int toLinear(ivec3 coord) {
    return coord.x + u_texDim * (coord.y + u_texDim * coord.z);
}

// Converte um índice linear 1D de volta para uma coordenada 3D
ivec3 fromLinear(int index) {
    int tex_dim_sq = u_texDim * u_texDim;
    int z = index / tex_dim_sq;
    int rem = index - z * tex_dim_sq;
    return ivec3(rem - (rem / u_texDim) * u_texDim, rem / u_texDim, z);
}

// Converte um "ponteiro" (cor RGB 0.0-1.0) de volta para 
// uma coordenada inteira de texel (ex: [0, 255])
ivec3 decodePointer(uvec3 pointer_rgb) {
    // Os valores já são os inteiros corretos (0-255)
    return ivec3(pointer_rgb);
}

// Determina em qual filho (0-7) o voxel do mundo está
int getchildIndices(ivec3 worldPos, ivec3 nodeMidPoint) {
    // O ponto médio calculado por divisão de inteiros é o INÍCIO do bloco da direita.
    bvec3 greater = greaterThanEqual(worldPos, nodeMidPoint);
    return int(greater.x) * 4 + int(greater.y) * 2 + int(greater.z);
}

void getChildBounds(int childIndices, inout ivec3 nodeMin, inout ivec3 nodeMax) {
    ivec3 mid = nodeMin + (nodeMax - nodeMin) / 2; // half split

    // Se o bit estiver set => este child é o "lado alto" => min = mid, max = old max
    // Caso contrário => este child é o "lado baixo" => min = old min, max = mid
    nodeMin.x = ((childIndices & 4) != 0) ? mid.x : nodeMin.x;
    nodeMax.x = ((childIndices & 4) != 0) ? nodeMax.x : mid.x;

    nodeMin.y = ((childIndices & 2) != 0) ? mid.y : nodeMin.y;
    nodeMax.y = ((childIndices & 2) != 0) ? nodeMax.y : mid.y;

    nodeMin.z = ((childIndices & 1) != 0) ? mid.z : nodeMin.z;
    nodeMax.z = ((childIndices & 1) != 0) ? nodeMax.z : mid.z;
}

// Converte os dados de propriedade (armazenados como 0-255) de volta
// para os valores float originais.
vec3 decodeProperties(vec4 texel) {
    return vec3(texel.r * 3.0, texel.g, texel.b);
}

// Obtém o texel de dados de um nó. 
// texelFetch usa coordenadas inteiras (ivec3).
uvec4 getNodeData(ivec3 coord) {
    // texelFetch em usampler3D retorna uvec4 com os valores exatos (0-255)
    return texelFetch(u_octreeTexture, coord, 0);
}

VoxelData octreeFind(ivec3 worldPos) {
    ivec3 currentNodeCoord = ivec3(0);
    ivec3 nodeMin = u_worldBoundsMin;
    ivec3 nodeMax = u_worldBoundsMax;

    VoxelData data;
    data.color = vec4(0.0);
    data.properties = vec3(0.0);
    data.nodeMin = nodeMin;
    data.nodeMax = nodeMax;

    // Mantenha suas verificações de borda (u_worldBoundsMin/Max) aqui...
    if (any(lessThan(worldPos, u_worldBoundsMin)) || any(greaterThanEqual(worldPos, u_worldBoundsMax))) {
       return data;
    }
    
    for (int i = 0; i < 16; i++) {
        // LEITURA DIRETA DE INTEIROS
        uvec4 nodeData = getNodeData(currentNodeCoord); 
        data.nodeMin = nodeMin;
        data.nodeMax = nodeMax;

        // Comparação direta de inteiros (>= 255u)
        if (nodeData.a >= LEAF_FLAG) {            
            int linearIndex = toLinear(currentNodeCoord);
            
            // Lê coordenadas
            ivec3 coordTexelCoord = fromLinear(linearIndex + 1);
            uvec4 coordData = getNodeData(coordTexelCoord);

            // Coordenada salva já é inteiro. Apenas cast para ivec3.
            ivec3 storedCoord = ivec3(coordData.rgb);

            // Lê Propriedades
            ivec3 propTexelCoord = fromLinear(linearIndex + 2);
            uvec4 propData = getNodeData(propTexelCoord);

            if (all(equal(storedCoord, worldPos)) && propData.a == 255u) {
                // Precisamos converter a cor de volta para float (0.0-1.0) para o raymarcher
                data.color.rgb = vec3(nodeData.rgb) / 255.0;
                data.color.a = float(coordData.a) / 255.0;
                
                // decodeProperties original esperava vec4 float. Adaptamos:
                vec4 propDataFloat = vec4(propData) / 255.0;
                data.properties = decodeProperties(propDataFloat);

                return data;
            }
            return data;
        }

        // Nó Interno
        if (nodeData.a <= INTERNAL_NODE_FLAG) {
            // Pega ponteiro direto (sem conversão de cor)
            ivec3 pointerBlockBaseCoord = decodePointer(nodeData.rgb);
            ivec3 midPoint = nodeMin + ((nodeMax - nodeMin) >> 1); // Divisão por 2 via shift é mais rápida
            int childIndices = getchildIndices(worldPos, midPoint);
            
            int linearBaseIndex = toLinear(pointerBlockBaseCoord);
            ivec3 childPointerCoord = fromLinear(linearBaseIndex + childIndices);
            
            uvec4 childPointerData = getNodeData(childPointerCoord);
            ivec3 nextNode = decodePointer(childPointerData.rgb);

            if (all(equal(nextNode, ivec3(0)))) {
                data.nodeMax = nodeMax;
                data.color = vec4(0.0); // Mark as empty
                return data;
            }

            currentNodeCoord = nextNode;
            getChildBounds(childIndices, nodeMin, nodeMax);
            continue;
        }
        return data;
    }
    return data;
}

// --- Raymarching ---

bool isInsideWorld(ivec3 c) {
    return all(greaterThanEqual(c, u_worldBoundsMin)) && all(lessThan(c, u_worldBoundsMax));
}

bool addRay(inout Ray rays[MAX_RAYS], Ray ray, inout int stackSize) {
    if (!ray.defined || stackSize >= MAX_RAYS) return false;
    rays[stackSize++] = ray;
    return true;
}


vec4 accumulateColors(Ray rays[MAX_RAYS], int rayCount) {
    vec3 result = vec3(0.0);
    float totalWeight = 0.0;
    
    // OTIMIZADO: Loop unrolling manual para MAX_RAYS=8
    if (rayCount > 0 && rays[0].defined) { result += rays[0].colorTint.rgb * rays[0].weight;}
    if (rayCount > 1 && rays[1].defined) { result += rays[1].colorTint.rgb * rays[1].weight;}
    if (rayCount > 2 && rays[2].defined) { result += rays[2].colorTint.rgb * rays[2].weight;}
    if (rayCount > 3 && rays[3].defined) { result += rays[3].colorTint.rgb * rays[3].weight;}
    if (rayCount > 4 && rays[4].defined) { result += rays[4].colorTint.rgb * rays[4].weight;}
    if (rayCount > 5 && rays[5].defined) { result += rays[5].colorTint.rgb * rays[5].weight;}
    if (rayCount > 6 && rays[6].defined) { result += rays[6].colorTint.rgb * rays[6].weight;}
    if (rayCount > 7 && rays[7].defined) { result += rays[7].colorTint.rgb * rays[7].weight;}

    return vec4(result, 1.0);
}

bool hitMarching(vec3 rayOrigin, vec3 rayDir, float rayIOF, out ivec3 hitMapPos, out vec3 hitPoint, out vec3 hitNormal, out VoxelData prevVoxel, out VoxelData hitVoxel) {
    
    vec3 rayPos = rayOrigin;
    float invLen = inversesqrt(dot(rayDir, rayDir));
    rayDir *= invLen;

    // Epsilon pequeno para cruzar a fronteira
    const float DIR_EPSILON = 1e-8;
    const float EPS = 0.0001;
    
    // Evita divisão por zero
    vec3 invDir;
    invDir.x = (abs(rayDir.x) < DIR_EPSILON) ? 1e20 : 1.0 / rayDir.x;
    invDir.y = (abs(rayDir.y) < DIR_EPSILON) ? 1e20 : 1.0 / rayDir.y;
    invDir.z = (abs(rayDir.z) < DIR_EPSILON) ? 1e20 : 1.0 / rayDir.z;

    // Pega o estado inicial
    ivec3 mapPos = ivec3(floor(rayPos));
    hitVoxel = octreeFind(mapPos);
    
    // Inicializa prevVoxel na primeira iteração
    prevVoxel = hitVoxel;
    
    // Define um limite de segurança para o loop
    for (int i = 0; i < 1024; ++i) {
        vec3 boxMin = vec3(hitVoxel.nodeMin);
        vec3 boxMax = vec3(hitVoxel.nodeMax);
        
        // 2. Calcule a distância para sair deste cubo (Ray-Box Exit)
        // (Similar ao tMax do DDA, mas para a caixa atual inteira)
        vec3 tMax = ((mix(boxMin, boxMax, greaterThan(rayDir, vec3(0.0)))) - rayPos) * invDir;
        
        // 3. Descubra qual face atingimos primeiro (o menor t)
        // Isso nos dá a NORMAL e a distância do passo.
        float tStep = min(tMax.x, min(tMax.y, tMax.z));
        int axis = (tMax.x < tMax.y) ? ((tMax.x < tMax.z) ? 0 : 2) : ((tMax.y < tMax.z) ? 1 : 2);
        hitNormal = vec3(0.0);
        hitNormal[axis] = -sign(rayDir[axis]);
        
        // Avança o raio para EXATAMENTE a borda
        // Nota: O 'tStep' é a distância geométrica exata até a parede.
        rayPos += rayDir * tStep;

        vec3 stepDir = sign(rayDir);

        // Se o raio for perfeitamente alinhado, a matemática acima é segura.
        // Mas para garantir que cruzamos a face no eixo correto:
        rayPos[axis] += stepDir[axis] * EPS;

        // Recalcula mapPos baseado no ponto levemente penetrado
        mapPos = ivec3(floor(rayPos));
        
        // Verifica se saiu do mundo
        if (!isInsideWorld(mapPos)) return false;

        // Salva o estado anterior antes de atualizar
        prevVoxel = hitVoxel;
        // Busca o NOVO voxel na nova posição
        hitVoxel = octreeFind(mapPos);
        
        // 5. Verifica mudança de meio (lógica de Hit)
        float prevRefrac = (prevVoxel.color.a > 0.0 && prevVoxel.properties[0] > 0.0) ? prevVoxel.properties[0] : rayIOF;
        float currentRefrac = (hitVoxel.color.a > 0.0 && hitVoxel.properties[0] > 0.0) ? hitVoxel.properties[0] : 1.0;

        if (abs(currentRefrac - prevRefrac) > EPS) {
            hitMapPos = mapPos;
            // O ponto de hit exato é a posição atual (que está na borda)
            hitPoint = rayPos;
            return true;
        }
    }
    
    return false;
}

// Simplified raymarch just for occlusion
bool inShadow(vec3 origin, vec3 lightDir, float maxDist) {
    vec3 rayPos = origin;

    const float DIR_EPSILON = 1e-8;
    const float EPS = 0.001;

    vec3 invDir;
    invDir.x = (abs(lightDir.x) < DIR_EPSILON) ? 1e20 : 1.0 / lightDir.x;
    invDir.y = (abs(lightDir.y) < DIR_EPSILON) ? 1e20 : 1.0 / lightDir.y;
    invDir.z = (abs(lightDir.z) < DIR_EPSILON) ? 1e20 : 1.0 / lightDir.z;

    ivec3 mapPos = ivec3(floor(rayPos));
    float distTraveled = 0.0;
    VoxelData vox;

    for (int i = 0; i < 32; ++i) {
        vox = octreeFind(mapPos);
        
        if (vox.color.a > 0.1) return true;

        vec3 boxMin = vec3(vox.nodeMin);
        vec3 boxMax = vec3(vox.nodeMax);
        
        vec3 pickMax;
        pickMax.x = (lightDir.x > 0.0) ? boxMax.x : boxMin.x;
        pickMax.y = (lightDir.y > 0.0) ? boxMax.y : boxMin.y;
        pickMax.z = (lightDir.z > 0.0) ? boxMax.z : boxMin.z;
        vec3 tMax = (pickMax - rayPos) * invDir;
        float tStep = min(tMax.x, min(tMax.y, tMax.z));
        int axis = (tMax.x < tMax.y) ? ((tMax.x < tMax.z) ? 0 : 2) : ((tMax.y < tMax.z) ? 1 : 2);
        
        rayPos += lightDir * tStep;
        rayPos[axis] += sign(lightDir[axis]) * EPS;
        mapPos = ivec3(floor(rayPos));
        
        distTraveled += tStep;
        if (!isInsideWorld(mapPos) || distTraveled > maxDist) return false;
    }
    return false;
}

vec4 raymarching_fromDir(vec3 rayOrigin, vec3 rayDir) {
    ivec3 thisMapPos = ivec3(floor(rayOrigin));
    VoxelData thisVoxel = octreeFind(thisMapPos);

    float startIOF = (thisVoxel.properties[0] > 0.0 && thisVoxel.properties[0] < 3.0) 
                      ? thisVoxel.properties[0] : 1.0;

    Ray rayStack[MAX_RAYS];
    Ray resultRays[MAX_RAYS];
    for (int i = 0; i < MAX_RAYS; ++i) {
        rayStack[i].defined = false;
        resultRays[i].defined = false;
        resultRays[i].weight = 0.0;
        resultRays[i].colorTint = vec4(0.0);
    }

    float invLen = inversesqrt(dot(rayDir, rayDir));
    rayDir = rayDir * invLen;
    rayStack[0] = Ray(
        rayOrigin, rayDir, startIOF, 1.0, true, globalLight, 0.0,
        thisVoxel.color.a > 0.0 ? thisVoxel.color : vec4(1.0),
        thisVoxel.color.a * 5.0
    );
    int stackSize = 1;
    int resultSize = 0;

    while (stackSize > 0) {
        Ray currentRay = rayStack[--stackSize];
        rayStack[stackSize].defined = false;
        
        if (!currentRay.defined) continue;

        ivec3 mapPos;
        vec3 hitPoint, hitNormal;
        VoxelData lastVoxel, hitVoxel;
        
        bool hit = hitMarching(currentRay.origin, currentRay.direction, currentRay.IOF,
                              mapPos, hitPoint, hitNormal, lastVoxel, hitVoxel);

        if (!hit) {
            // Apply Beer's Law and add to results
            vec4 transmittedColor = currentRay.colorTint;
            if (currentRay.distanceInMedium > 1e-6 && currentRay.mediumDensity > 0.0) {
                vec3 absorption = exp(-currentRay.mediumDensity * currentRay.distanceInMedium * 
                                      (vec3(1.0) - currentRay.mediumColor.rgb));
                transmittedColor.rgb *= absorption;
            }
            
            if (resultSize < MAX_RAYS) {
                resultRays[resultSize++] = Ray(
                    vec3(0.0), vec3(0.0), 0.0, currentRay.weight, true,
                    transmittedColor * skyColor, 0.0, vec4(0.0), 0.0
                );
            }
            continue;
        }

        // Update distance traveled through current medium
        currentRay.distanceInMedium += length(hitPoint - currentRay.origin);
        
        if (hitVoxel.color.a <= 0.0) hitVoxel.properties = vec3(1.0, 0.0, 0.0);
        if (lastVoxel.color.a <= 0.0) lastVoxel.properties = currentRay.IOF > 0.0 ? vec3(0.0) : vec3(1.0, 0.0, 0.0);

        vec3 normal = length(hitNormal) > 0.0 ? hitNormal : vec3(0.0, 1.0, 0.0);
        vec3 finalLight = vec3(0.2);
        if (!inShadow(hitPoint + normal * 1e-3, lightDir, 256.0)) {
            finalLight += vec3(max(dot(normal, lightDir), 0.0));
        }
        
        // Determine surface color based on which side we're hitting
        vec4 surfaceColor = hitVoxel.color.a > 0.0 ? hitVoxel.color : lastVoxel.color;
        float n2 = hitVoxel.properties[0] > 0.0 ? hitVoxel.properties[0] : 1.0;
        float n1 = lastVoxel.properties[0] > 0.0 ? lastVoxel.properties[0] : 1.0;

        vec3 incidentDir = currentRay.direction;

        // Apply Beer's Law
        vec4 transmittedColor = currentRay.colorTint;
        if (currentRay.distanceInMedium > 1e-6 && currentRay.mediumDensity > 0.0) {
            vec3 absorption = exp(-currentRay.mediumDensity * currentRay.distanceInMedium * 
                                  (vec3(1.0) - currentRay.mediumColor.rgb));
            transmittedColor.rgb *= absorption;
        }

        // === TRANSPARENT/TRANSLUCENT SURFACES ===
        if (surfaceColor.a < 1) {
            float cosi = dot(incidentDir, normal);
            
            if (cosi > 0.0) {
                normal = -normal;
                float tmp = n1; n1 = n2; n2 = tmp;
            }

            vec3 refractDir = refract(incidentDir, normal, n1 / n2);

            float R0 = (n1 - n2) / (n1 + n2) * (n1 - n2) / (n1 + n2);
            float cosTheta = max(0.0, dot(-incidentDir, normal));
            float fresnel = clamp(R0 + (1.0 - R0) * pow(1.0 - cosTheta, 5.0), 0.0, 1.0);

            bool hasTIR = length(refractDir) < 0.001;
            float reflectIntensity = fresnel;
            float refractIntensity = hasTIR ? 0.0 : (1.0 - fresnel);

            // DONT WASTE ENERGY YOU SICK FUCK
            if(stackSize == MAX_RAYS || reflectIntensity <= 0.001 || refractIntensity <= 0.001){
                vec4 litSurfaceColor = vec4(surfaceColor.rgb * finalLight, 1.0);
                Ray finalRay;
                finalRay.defined = true;
                finalRay.weight = currentRay.weight;
                finalRay.colorTint = transmittedColor * litSurfaceColor;
                
                addRay(resultRays, finalRay, resultSize);
                continue;
            }

            // ---- Reflection ray ----
            if (reflectIntensity > 0.001 && stackSize < MAX_RAYS) {
                float reflectWeight = currentRay.weight * reflectIntensity;
                if (reflectWeight > 1e-4)
                    rayStack[stackSize++] = Ray(
                        hitPoint + normal * 1e-4, reflect(incidentDir, normal), n1,
                        reflectWeight, true,
                        transmittedColor, 0.0, lastVoxel.color, lastVoxel.color.a * 5.0
                    );
            }

            // ---- Refraction ray ----
            if (refractIntensity > 0.001 && stackSize < MAX_RAYS && !hasTIR) {
                rayStack[stackSize++] = Ray(
                    hitPoint - normal * 1e-4, refractDir, n2,
                    currentRay.weight * refractIntensity, true,
                    transmittedColor, 0.0, hitVoxel.color, hitVoxel.color.a * 5.0
                );
            }
        }
        else {
            // === OPAQUE SURFACE ===
            float specularFactor = hitVoxel.properties[2];
            float diffuseFactor = 1.0 - specularFactor;

            vec4 litSurfaceColor = vec4(surfaceColor.rgb * finalLight, 1.0);

            // Diffuse component
            if (diffuseFactor > 0.01 && resultSize < MAX_RAYS) {
                Ray finalRay;
                finalRay.defined = true;
                finalRay.weight = currentRay.weight * diffuseFactor;
                finalRay.colorTint = transmittedColor * litSurfaceColor;
                
                addRay(resultRays, finalRay, resultSize);
            }

            // Specular reflection
            if (specularFactor > 0.01) {
                vec3 reflectDir = reflect(incidentDir, normal);
                float reflectWeight = currentRay.weight * specularFactor;
                if (reflectWeight > 1e-4) {
                    rayStack[stackSize++] = Ray(
                        hitPoint + normal * 1e-4, reflectDir, n1,
                        reflectWeight, true,
                        transmittedColor, 0.0, vec4(1.0), 0.0
                    );
                }
            }
        }
    }
    
    return accumulateColors(resultRays,resultSize);
}

void main() {
    ivec2 pixel_coords = ivec2(gl_GlobalInvocationID.xy);
    ivec2 dims = imageSize(destTex);

    if (pixel_coords.x < 0 || pixel_coords.x >= dims.x || pixel_coords.y < 0 || pixel_coords.y >= dims.y) return;

    float u = (float(pixel_coords.x) / float(dims.x)) * 2.0 - 1.0;
    float v = (float(pixel_coords.y) / float(dims.y)) * 2.0 - 1.0;

    vec4 clip = vec4(u, v, -1.0, 1.0);
    vec4 view = invProjection * clip;
    if (abs(view.w) > 1e-6) view /= view.w;
    vec3 viewDir = normalize(view.xyz);
    vec3 worldDir = normalize((invView * vec4(viewDir, 0.0)).xyz);

    vec4 finalColor = raymarching_fromDir(cameraPos.xyz, worldDir);

    if (length(finalColor.rgb) == 0.0) finalColor = skyColor;

    imageStore(destTex, pixel_coords, finalColor);
}