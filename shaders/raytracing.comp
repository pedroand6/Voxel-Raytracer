#version 450 core

layout (local_size_x = 8, local_size_y = 8, local_size_z = 1) in;
layout (rgba8, binding = 0) uniform writeonly image2D destTex;

layout (std140, binding = 1) uniform Camera {
    mat4 invProjection;
    mat4 invView;
    vec3 cameraPos;
};

const ivec3 worldSize = ivec3(64, 64, 64);
const int MAX_RAYS = 8;
const vec4 skyColor = vec4(0.5, 0.7, 1.0, 1.0);

uint get_red_rgba(uint color) { return (color >> 24) & 0xffu; }
uint get_green_rgba(uint color) { return (color >> 16) & 0xffu; }
uint get_blue_rgba(uint color) { return (color >> 8) & 0xffu; }
uint get_alpha_rgba(uint color) { return color & 0xffu; }

vec4 rgbaColor(uint color) {
    return vec4(
        float(get_red_rgba(color)) / 255.0,
        float(get_green_rgba(color)) / 255.0,
        float(get_blue_rgba(color)) / 255.0,
        float(get_alpha_rgba(color)) / 255.0
    );
}

vec4 blendTex(vec4 tex_1, vec4 tex_2, vec4 weights){
    vec4 newTex;
    newTex.r = mix(tex_1.r, tex_2.r, weights.r);
    newTex.g = mix(tex_1.g, tex_2.g, weights.g);
    newTex.b = mix(tex_1.b, tex_2.b, weights.b);
    newTex.a = mix(tex_1.a, tex_2.a, weights.a);
    return newTex;
}

struct Voxel {
    float refraction;
    float emmission;
    float mettalicity;
};

struct VoxelObj {
    ivec3 coord;
    uint color;
    Voxel voxel;
    float padding;
};

struct Ray {
    vec3 origin;
    vec3 direction;
    float IOF;
    vec4 weight;
    bool defined;
};

layout (std430, binding = 2) buffer VoxelBuffer {
    VoxelObj voxels[];
};

bool isInsideWorld(ivec3 c) {
    return all(greaterThanEqual(c, ivec3(0))) && all(lessThan(c, worldSize));
}

int getVoxelIndex(ivec3 coord) {
    if(!isInsideWorld(coord)) return -1;
    return coord.x + coord.y * worldSize.x + coord.z * worldSize.x * worldSize.y;
}

bool popRay(inout Ray rays[MAX_RAYS], inout int stackSize) {
    if (stackSize <= 0) return false;
    stackSize -= 1;
    rays[stackSize].defined = false;
    return true;
}

bool addRay(inout Ray rays[MAX_RAYS], in Ray ray, inout int stackSize) {
    if (stackSize >= MAX_RAYS) { // evita overflow
        return false;
    }
    rays[stackSize] = ray;
    stackSize += 1;
    return true;
}

vec3 map_vec3(vec3 value, vec3 min1, vec3 max1, vec3 min2, vec3 max2) {
  return min2 + (value - min1) * (max2 - min2) / (max1 - min1);
}

vec4 getVoxelColor(ivec3 coord) {
    int idx = getVoxelIndex(coord);
    if (idx < 0) return vec4(0.0);
    return rgbaColor(voxels[idx].color);
}

// Sample a scalar 'density' at integer voxel coordinates (0..1 alpha)
float sampleDensity(ivec3 c) {
    vec4 ccol = getVoxelColor(c);
    return ccol.a;
}

// Compute a smooth normal from neighboring voxel densities using central differences.
// This gives smoother normals across flat surfaces (like water planes).
vec3 computeVoxelNormal(ivec3 pos) {
    // central differences across integer neighbors
    float dx = sampleDensity(pos + ivec3(1,0,0)) - sampleDensity(pos + ivec3(-1,0,0));
    float dy = sampleDensity(pos + ivec3(0,1,0)) - sampleDensity(pos + ivec3(0,-1,0));
    float dz = sampleDensity(pos + ivec3(0,0,1)) - sampleDensity(pos + ivec3(0,0,-1));

    vec3 g = vec3(dx, dy, dz);
    float len = length(g);
    if (len < 1e-4) return vec3(0.0); // no gradient
    // gradient points toward increasing density; surface normal should point outward from solid
    return normalize(-g);
}

// March the ray through the voxel grid and return the first solid voxel hit.
// Returns true and fills hitMapPos, prevMapPos, hitPoint (world-space) and hitNormal (unit).
bool hitMarching(in Ray thisRay, out ivec3 hitMapPos, out ivec3 prevMapPos, out vec3 hitPoint, out vec3 hitNormal) {
    const float EPS = 1e-6;
    vec3 origin = thisRay.origin;
    vec3 dir = normalize(thisRay.direction);

    // inicializa pos do voxel onde o raio está
    ivec3 mapPos = ivec3(floor(origin));
    prevMapPos = mapPos;

    // step sign for each axis (integer -1, 0, +1)
    ivec3 stepSign = ivec3(sign(dir));

    // tDelta: distance along ray to cross one voxel on each axis
    vec3 tDelta = vec3(
        abs(dir.x) > EPS ? abs(1.0 / dir.x) : 1e30,
        abs(dir.y) > EPS ? abs(1.0 / dir.y) : 1e30,
        abs(dir.z) > EPS ? abs(1.0 / dir.z) : 1e30
    );

    // next voxel boundary (first crossing)
    vec3 voxelBoundary = floor(origin) + vec3(step(0.0, dir.x), step(0.0, dir.y), step(0.0, dir.z));

    vec3 tMax = vec3(
        abs(dir.x) > EPS ? (voxelBoundary.x - origin.x) / dir.x : 1e30,
        abs(dir.y) > EPS ? (voxelBoundary.y - origin.y) / dir.y : 1e30,
        abs(dir.z) > EPS ? (voxelBoundary.z - origin.z) / dir.z : 1e30
    );

    int startIndex = getVoxelIndex(mapPos);

    // DDA: step first then test the new voxel so we can compute the exact hit t & normal
    for (int i = 0; i < 1024; ++i) {
        // choose axis to step
        int axis = 0;
        if (tMax.x < tMax.y) {
            axis = (tMax.x < tMax.z) ? 0 : 2;
        } else {
            axis = (tMax.y < tMax.z) ? 1 : 2;
        }

        float tHit = 0.0;
        if (axis == 0) {
            mapPos.x += stepSign.x;
            tHit = tMax.x;
            tMax.x += tDelta.x;
        } else if (axis == 1) {
            mapPos.y += stepSign.y;
            tHit = tMax.y;
            tMax.y += tDelta.y;
        } else {
            mapPos.z += stepSign.z;
            tHit = tMax.z;
            tMax.z += tDelta.z;
        }

        // test the voxel we just entered
        int currentIndex = getVoxelIndex(mapPos);
        int prevIndex = getVoxelIndex(prevMapPos);
        if (currentIndex >= 0) {
            vec4 vcol = rgbaColor(voxels[currentIndex].color);
            float prevRefrac = voxels[prevIndex].voxel.refraction;
            if(prevIndex < 0) prevRefrac = 1.0;

            //FIXME
            if (vcol.a > 0 && voxels[currentIndex].voxel.refraction != voxels[prevIndex].voxel.refraction 
                && currentIndex != startIndex ) {
                hitMapPos = mapPos;
                prevMapPos = mapPos - stepSign * ((axis==0) ? ivec3(1,0,0) : (axis==1 ? ivec3(0,1,0) : ivec3(0,0,1)));
                // precise hit point in world-space
                hitPoint = origin + dir * tHit;
                // normal points opposite to the step (faces toward previous cell)
                if (axis == 0) hitNormal = vec3(-float(stepSign.x), 0.0, 0.0);
                else if (axis == 1) hitNormal = vec3(0.0, -float(stepSign.y), 0.0);
                else hitNormal = vec3(0.0, 0.0, -float(stepSign.z));
                return true;
            }
        }
    }

    return false;
}

vec4 raymarching_fromDir(vec3 rayOrigin, vec3 rayDir) {
    vec4 finalColor = vec4(0.0);

    ivec3 thisMapPos = ivec3(floor(rayOrigin));
    int thisVoxelIndex = getVoxelIndex(thisMapPos);
    float startIOF = 1.0; // valor default para fora (ar)
    if (thisVoxelIndex >= 0) startIOF = voxels[thisVoxelIndex].voxel.refraction;

    Ray rayStack[MAX_RAYS];
    for (int i = 0; i < MAX_RAYS; ++i) rayStack[i].defined = false;

    rayStack[0].origin = rayOrigin;
    rayStack[0].direction = normalize(rayDir);
    rayStack[0].IOF = startIOF;
    rayStack[0].defined = true;
    rayStack[0].weight = vec4(1.0);
    int stackSize = 1;

    while (stackSize > 0) {
        int rayIndex = stackSize - 1;
        Ray currentRay = rayStack[rayIndex];
        popRay(rayStack, stackSize);

        if (!currentRay.defined) continue;

        ivec3 mapPos;
        ivec3 prevMapPos;
        vec3 hitPoint;
        vec3 hitNormal;
        bool hit = hitMarching(currentRay, mapPos, prevMapPos, hitPoint, hitNormal);

        if (!hit) {
            finalColor = blendTex(finalColor, skyColor, currentRay.weight);
            continue;
        }

        int index = getVoxelIndex(mapPos);
        VoxelObj thisVoxel = voxels[index];
        int prevIndex = getVoxelIndex(prevMapPos);
        VoxelObj lastVoxel;
        if (prevIndex >= 0) lastVoxel = voxels[prevIndex];
        else lastVoxel.voxel.refraction = currentRay.IOF;

        vec4 voxelColor = rgbaColor(thisVoxel.color);

        // precise normal and contact point from DDA
        vec3 normal = hitNormal;
        if (length(normal) == 0.0) normal = vec3(0.0, 1.0, 0.0); // fallback

        vec3 lightDir = normalize(vec3(0.4, 1.0, 0.4));
        vec3 rayContact = hitPoint;

        float ambientStrength = 0.2;
        vec3 ambient = vec3(ambientStrength);

        float diff = max(dot(normal, lightDir), 0.0);
        vec3 diffuse = vec3(diff);

        // Esta parte calcula a iluminação local (Ambiente + Difusa)
        Ray lightRay;
        lightRay.origin = rayContact + normal * 1e-3; 
        lightRay.direction = lightDir;
        lightRay.IOF = currentRay.IOF; // Sombra no meio atual
        lightRay.defined = true;
        ivec3 shadowHit, shadowPrev;
        vec3 shadowPoint, shadowNormal;
        if (hitMarching(lightRay, shadowHit, shadowPrev, shadowPoint, shadowNormal)) {
            diffuse = vec3(0.0);
        }

        vec3 finalLight = ambient + diffuse;
        
        // Adicionamos a cor local ao resultado final, ponderada pelo fator difuso
        vec4 corLocal = vec4(voxelColor.rgb * finalLight, voxelColor.a);

        float refracIndex = thisVoxel.voxel.refraction;
        float prevRefracIndex = lastVoxel.voxel.refraction;

        if(prevRefracIndex <= 0.0) prevRefracIndex = 1.0;

        if (abs(refracIndex - prevRefracIndex) > 1e-6 && refracIndex != 3.0 && prevRefracIndex != 3.0) {
            // Snell's Law
            vec3 incidentDir = normalize(currentRay.direction);
            float n1 = prevRefracIndex;
            float n2 = refracIndex;
            float eta = n1 / n2;

            vec3 refractDir = refract(incidentDir, normal, eta);
            vec3 reflectDir = reflect(incidentDir, normal);

            float R0 = pow((n1 - n2) / (n1 + n2), 2.0);
            float cosTheta = max(0.0, dot(-incidentDir, normal));
            float reflectIntensity = R0 + (1.0 - R0) * pow(1.0 - cosTheta, 5.0);

            if (reflectIntensity > 0.01) {
                Ray reflectionRay;
                reflectionRay.direction = reflectDir;
                reflectionRay.origin = rayContact + normal * 1e-4;
                reflectionRay.defined = true;
                reflectionRay.IOF = prevRefracIndex;
                reflectionRay.weight = currentRay.weight * reflectIntensity;
                addRay(rayStack, reflectionRay, stackSize);
            }

            float refractIntensity = 1.0 - reflectIntensity;
            float traveled = 0.0;
            vec3 sigma = corLocal.a * (1.0 - corLocal.rgb);
            vec3 trans = vec3(1.0);
            if (refractIntensity > 0.01 && length(refractDir) > 1e-9) {
                Ray refractionRay;
                refractionRay.direction = refractDir;
                refractionRay.origin = rayContact - normal * 1e-4;
                refractionRay.defined = true;
                refractionRay.IOF = refracIndex;

                ivec3 refrMapPos, refrMapPrev;
                vec3 refrHitPoint, refrNormal;
                if (hitMarching(refractionRay, refrMapPos, refrMapPrev, refrHitPoint, refrNormal)) {
                    traveled = length(refrHitPoint - refractionRay.origin);
                }

                trans = exp(-sigma * traveled);
                refractionRay.weight = (vec4(trans, 1.0) * currentRay.weight) * refractIntensity;

                addRay(rayStack, refractionRay, stackSize);
            }
        }
        else {
            // Esta superfície é opaca. Pode ser Difusa (pedra) ou Especular (espelho).
            // Usamos 'k' como o "Fator Especular" (0.0 = 100% difuso, 1.0 = 100% espelho)
            float specularFactor = thisVoxel.voxel.mettalicity;
            float diffuseFactor = 1.0 - specularFactor;
            
            vec3 incidentDir = normalize(currentRay.direction); // Usado para reflexão

            // --- 1. Calcular componente DIFUSA (se houver) ---
            if (diffuseFactor > 0.01) {
                finalColor = blendTex(finalColor, corLocal, currentRay.weight * diffuseFactor);
            }

            // --- 2. Calcular componente ESPECULAR (Espelho) (se houver) ---
            if (specularFactor > 0.01) {
                // Esta parte lança um novo raio de reflexão
                vec3 reflectDir = reflect(incidentDir, normal);
                Ray reflectionRay;
                reflectionRay.direction = reflectDir;
                reflectionRay.origin = rayContact + normal * 1e-4; // Offset para fora
                reflectionRay.defined = true;
                reflectionRay.IOF = prevRefracIndex; // Raio refletido está no mesmo meio
                
                // Adiciona o raio de reflexão, ponderado pelo fator especular
                reflectionRay.weight = currentRay.weight * specularFactor;
                addRay(rayStack, reflectionRay, stackSize);

                finalColor = blendTex(finalColor, corLocal, currentRay.weight * diffuseFactor);
            }
        }
    } // fim do while
    return finalColor;
}

void main() {
    ivec2 pixel_coords = ivec2(gl_GlobalInvocationID.xy);
    ivec2 dims = imageSize(destTex);

    if (pixel_coords.x < 0 || pixel_coords.x >= dims.x || pixel_coords.y < 0 || pixel_coords.y >= dims.y) return;

    float u = (float(pixel_coords.x) / float(dims.x)) * 2.0 - 1.0;
    float v = (float(pixel_coords.y) / float(dims.y)) * 2.0 - 1.0;

    // Geração correta do raio: NDC -> view -> world
    vec4 clip = vec4(u, v, -1.0, 1.0); // z = -1 (near plane)
    vec4 view = invProjection * clip;
    // divide por w para obter coordenada em view space
    if (abs(view.w) > 1e-6) view /= view.w;
    vec3 viewDir = normalize(view.xyz);
    vec3 worldDir = normalize((invView * vec4(viewDir, 0.0)).xyz);

    vec4 finalColor = raymarching_fromDir(cameraPos, worldDir);

    if (finalColor.a == 0.0) finalColor = skyColor;

    imageStore(destTex, pixel_coords, finalColor);
}