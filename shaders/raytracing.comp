#version 450 core

// Tamanho do grupo de trabalho. 8x8 = 64 threads por grupo, um bom começo.
layout (local_size_x = 8, local_size_y = 8, local_size_z = 1) in;

// A textura de saída onde vamos desenhar.
// O 'binding = 0' corresponde ao glBindImageTexture(0, ...).
layout (rgba8, binding = 0) uniform writeonly image2D destTex;

// UBO com os dados da câmera
layout (std140, binding = 1) uniform Camera {
    mat4 invProjection;
    mat4 invView;
    vec3 cameraPos;
};

// SSBO com os dados dos voxels
// O 'binding = 2' corresponde ao glBindBufferBase(..., 2, ...).
struct Voxel {
    vec4 color; // r, g, b, tipo
};

layout (std430, binding = 2) buffer VoxelBuffer {
    Voxel voxels[];
};

vec3 map(vec3 value, vec3 min1, vec3 max1, vec3 min2, vec3 max2) {
  return min2 + (value - min1) * (max2 - min2) / (max1 - min1);
}

// Dimensões do nosso mundo de voxels
const ivec3 worldSize = ivec3(64, 64, 64);

// Pegar o indice pela coordenada 3D
int getVoxelIndex(ivec3 coord) {
    return coord.x + coord.y * worldSize.x + coord.z * worldSize.x * worldSize.y;
}

// Função para obter um voxel de uma coordenada 3D
// Retorna a cor se o voxel for sólido (alfa > 0), senão vec4(0)
vec4 getVoxel(ivec3 coord) {
    // Verifica se a coordenada está dentro dos limites do mundo
    if (any(lessThan(coord, ivec3(0))) || any(greaterThanEqual(coord, worldSize))) {
        return vec4(0.0);
    }
    
    // Converte coordenada 3D para um índice 1D
    int index = getVoxelIndex(coord);

    vec4 voxelColor = voxels[index].color;
    if (voxelColor.a > 0.0) { // Consideramos alfa > 0 como um voxel sólido
        return voxelColor;
    }
    
    return vec4(0.0);
}

bool isInShadow(vec3 rayOrigin, vec3 rayDir) {
    vec3 rayStep = sign(rayDir);
    vec3 tDelta = abs(1.0 / rayDir);
    vec3 voxelBoundary = floor(rayOrigin) + step(0.0, rayDir);
    vec3 tMax = (voxelBoundary - rayOrigin) / rayDir;
    ivec3 mapPos = ivec3(floor(rayOrigin));

    int index = getVoxelIndex(mapPos);

    // Marchamos pelo grid (por uma distância máxima para a sombra)
    for (int i = 0; i < 128; i++) {
        if (getVoxel(mapPos).a > 0.0 && getVoxelIndex(mapPos) != index) {
            return true;
        }

        // avançamos para o próximo voxel
        if (tMax.x < tMax.y) {
            if (tMax.x < tMax.z) {
                mapPos.x += int(rayStep.x); tMax.x += tDelta.x;
            } else {
                mapPos.z += int(rayStep.z); tMax.z += tDelta.z;
            }
        } else {
            if (tMax.y < tMax.z) {
                mapPos.y += int(rayStep.y); tMax.y += tDelta.y;
            } else {
                mapPos.z += int(rayStep.z); tMax.z += tDelta.z;
            }
        }
    }

    return false;
}

vec4 redirectRay (vec3 rayOrigin, vec3 rayDir) {
    vec3 rayStep = sign(rayDir);
    vec3 tDelta = abs(1.0 / rayDir);
    vec3 voxelBoundary = floor(rayOrigin) + step(0.0, rayDir);
    vec3 tMax = (voxelBoundary - rayOrigin) / rayDir;
    ivec3 mapPos = ivec3(floor(rayOrigin));

    int index = getVoxelIndex(mapPos);

    // Marchamos pelo grid (por uma distância máxima para a sombra)
    for (int i = 0; i < 128; i++) {
        // avançamos para o próximo voxel
        if (tMax.x < tMax.y) {
            if (tMax.x < tMax.z) {
                mapPos.x += int(rayStep.x); tMax.x += tDelta.x;
            } else {
                mapPos.z += int(rayStep.z); tMax.z += tDelta.z;
            }
        } else {
            if (tMax.y < tMax.z) {
                mapPos.y += int(rayStep.y); tMax.y += tDelta.y;
            } else {
                mapPos.z += int(rayStep.z); tMax.z += tDelta.z;
            }
        }

        vec4 voxColor = getVoxel(mapPos);

        if (voxColor.a > 0.0 && getVoxelIndex(mapPos) != index) {
            return voxColor;
        }
    }

    return vec4(0.0);
}

vec4 raymarching(vec4 target, vec3 rayOrigin) {
    vec3 rayDir = vec3(invView * vec4(normalize(target.xyz), 0.0));

    // --- Algoritmo de Travessia de Voxel (DDA Simplificado) ---
    vec3 rayStep = sign(rayDir);
    vec3 tDelta = abs(1.0 / rayDir);
    vec3 voxelBoundary = floor(rayOrigin) + step(0.0, rayDir);
    vec3 tMax = (voxelBoundary - rayOrigin) / rayDir;
    ivec3 mapPos = ivec3(floor(rayOrigin));
    ivec3 prevMapPos = mapPos;

    bool hit = false;
    vec4 finalColor = vec4(0.0);

    // Marcha pelo grid por um número máximo de passos
    for (int i = 0; i < 512; i++) {
        vec4 voxel = getVoxel(mapPos);
        
        if (voxel.a > 0.0) {
            vec3 normal = normalize(sign(vec3(prevMapPos - mapPos)));
            if (length(normal) == 0.0) normal = vec3(0.0, 1.0, 0.0); // fallback

            vec3 lightDir = normalize(vec3(0.4, 1.0, 0.4));
            vec3 rayContact = vec3(mapPos) + normal;

            if(voxel == vec4(0.0, 0.0, 1.0, 1.0)) {
                vec3 refractDir = refract(normalize(rayDir), normal, 1.0 / 1.5);

                // Se o voxel for azul, aplicamos um efeito de espelho
                voxel = mix(voxel, redirectRay(rayContact, refractDir), 0.25);
            }

            // Luz ambiente
            float ambientStrength = 0.2;
            vec3 ambient = vec3(ambientStrength);

            // Contribuição da luz direta (difusa)
            //    max(..., 0.0) impede que faces opostas à luz fiquem com iluminação negativa
            float diff = max(dot(normal, lightDir), 0.0);
            vec3 diffuse = vec3(diff);

            if (isInShadow(rayContact, lightDir)) {
                diffuse = vec3(0.0); // Se estiver em sombra, anula a contribuição da luz direta
            }

            vec3 finalLight = ambient + diffuse;
            finalColor = vec4(voxel.rgb * finalLight, 1.0);

            hit = true;
            break;
        }

        prevMapPos = mapPos;
        
        // Avança para o próximo voxel (lógica DDA)
        if (tMax.x < tMax.y) {
            if (tMax.x < tMax.z) {
                mapPos.x += int(rayStep.x);
                tMax.x += tDelta.x;
            } else {
                mapPos.z += int(rayStep.z);
                tMax.z += tDelta.z;
            }
        } else {
            if (tMax.y < tMax.z) {
                mapPos.y += int(rayStep.y);
                tMax.y += tDelta.y;
            } else {
                mapPos.z += int(rayStep.z);
                tMax.z += tDelta.z;
            }
        }
    }

    return finalColor;
}

void main() {
    // Coordenada do pixel para o qual este thread é responsável
    ivec2 pixel_coords = ivec2(gl_GlobalInvocationID.xy);
    ivec2 dims = imageSize(destTex); // Pega o tamanho da textura

    // Normaliza as coordenadas do pixel para o intervalo [-1, 1]
    float u = (float(pixel_coords.x) / float(dims.x)) * 2.0 - 1.0;
    float v = (float(pixel_coords.y) / float(dims.y)) * 2.0 - 1.0;

    // --- Geração do Raio ---
    // Transforma as coordenadas da tela para o espaço do mundo
    vec4 target = invProjection * vec4(u, v, 1.0, 1.0);
    vec4 finalColor = raymarching(target, cameraPos);

    // Se não houve colisão, use a cor da skybox
    if (finalColor.a == 0.0) {
        finalColor = vec4(0.5, 0.7, 1.0, 1.0); // Cor do céu (azul claro)
    }

    // Escreve a cor final na textura de saída
    imageStore(destTex, pixel_coords, finalColor);
}