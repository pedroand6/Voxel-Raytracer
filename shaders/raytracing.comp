#version 450 core

layout (local_size_x = 8, local_size_y = 8, local_size_z = 1) in;
layout (rgba8, binding = 0) uniform writeonly image2D destTex;

layout (std140, binding = 1) uniform Camera {
    mat4 invProjection;
    mat4 invView;
    vec3 cameraPos;
};

const ivec3 worldSize = ivec3(64, 64, 64);
const int MAX_RAYS = 8;
const vec4 skyColor = vec4(0.5, 0.7, 1.0, 1.0);

uint get_red_rgba(uint color) { return (color >> 24) & 0xffu; }
uint get_green_rgba(uint color) { return (color >> 16) & 0xffu; }
uint get_blue_rgba(uint color) { return (color >> 8) & 0xffu; }
uint get_alpha_rgba(uint color) { return color & 0xffu; }

vec4 rgbaColor(uint color) {
    return vec4(
        float(get_red_rgba(color)) / 255.0,
        float(get_green_rgba(color)) / 255.0,
        float(get_blue_rgba(color)) / 255.0,
        float(get_alpha_rgba(color)) / 255.0
    );
}

struct Voxel {
    float refraction;
    float emmission;
    float mettalicity;
};

struct VoxelObj {
    ivec3 coord;
    uint color;
    Voxel voxel;
    float padding;
};

struct Ray {
    vec3 origin;
    vec3 direction;
    float IOF;
    float weight;
    bool defined;
    vec4 color;
};

layout (std430, binding = 2) buffer VoxelBuffer {
    VoxelObj voxels[];
};

bool isInsideWorld(ivec3 c) {
    return all(greaterThanEqual(c, ivec3(0))) && all(lessThan(c, worldSize));
}

int getVoxelIndex(ivec3 coord) {
    if(!isInsideWorld(coord)) return -1;
    return coord.x + coord.y * worldSize.x + coord.z * worldSize.x * worldSize.y;
}

bool popRay(inout Ray rays[MAX_RAYS], inout int stackSize) {
    if (stackSize <= 0) return false;
    stackSize -= 1;
    rays[stackSize].defined = false;
    return true;
}

// Safe addRay that never writes out-of-bounds
bool addRay(inout Ray rays[MAX_RAYS], Ray ray, inout int stackSize) {
    if (!ray.defined) return false;
    if (stackSize < 0 || stackSize >= MAX_RAYS) {
        // stack full, skip to avoid GPU crash
        return false;
    }
    rays[stackSize] = ray;
    stackSize += 1;
    return true;
}

vec3 map_vec3(vec3 value, vec3 min1, vec3 max1, vec3 min2, vec3 max2) {
  return min2 + (value - min1) * (max2 - min2) / (max1 - min1);
}

vec4 getVoxelColor(ivec3 coord) {
    int idx = getVoxelIndex(coord);
    if (idx < 0) return vec4(0.0);
    return rgbaColor(voxels[idx].color);
}

// Sample a scalar 'density' at integer voxel coordinates (0..1 alpha)
float sampleDensity(ivec3 c) {
    vec4 ccol = getVoxelColor(c);
    return ccol.a;
}

// Compute a smooth normal from neighboring voxel densities using central differences.
// This gives smoother normals across flat surfaces (like water planes).
vec3 computeVoxelNormal(ivec3 pos) {
    // central differences across integer neighbors
    float dx = sampleDensity(pos + ivec3(1,0,0)) - sampleDensity(pos + ivec3(-1,0,0));
    float dy = sampleDensity(pos + ivec3(0,1,0)) - sampleDensity(pos + ivec3(0,-1,0));
    float dz = sampleDensity(pos + ivec3(0,0,1)) - sampleDensity(pos + ivec3(0,0,-1));

    vec3 g = vec3(dx, dy, dz);
    float len = length(g);
    if (len < 1e-4) return vec3(0.0); // no gradient
    // gradient points toward increasing density; surface normal should point outward from solid
    return normalize(-g);
}

// Calculate the final mixed color of all the rays accumulated (physically correct)
vec4 accumulateColors(Ray rays[MAX_RAYS], vec4 colorBase) {
    vec3 lightmap = vec3(0.0);
    float totalWeight = 0.0;

    for (int i = 0; i < MAX_RAYS; ++i) {
        if (!rays[i].defined) continue;
        // acumula cor ponderada
        lightmap += rays[i].color.rgb * rays[i].weight;
        totalWeight += rays[i].weight;
    }

    if (totalWeight > 0.0) lightmap /= totalWeight;

    if(colorBase.a >= 1.0) 
        return vec4(lightmap, 1.0);
    else 
        return vec4(mix(lightmap, colorBase.rgb, colorBase.a), 1.0);
}

// March the ray through the voxel grid and return the first solid voxel hit.
// Returns true and fills hitMapPos, prevMapPos, hitPoint (world-space) and hitNormal (unit).
bool hitMarching(in Ray thisRay, out ivec3 hitMapPos, out ivec3 prevMapPos, out vec3 hitPoint, out vec3 hitNormal) {
    const float EPS = 1e-6;
    vec3 origin = thisRay.origin;
    vec3 dir = normalize(thisRay.direction);

    // inicializa pos do voxel onde o raio está
    ivec3 mapPos = ivec3(floor(origin));
    prevMapPos = mapPos;

    // step sign for each axis (integer -1, 0, +1)
    ivec3 stepSign = ivec3(sign(dir));

    // tDelta: distance along ray to cross one voxel on each axis
    vec3 tDelta = vec3(
        abs(dir.x) > EPS ? abs(1.0 / dir.x) : 1e30,
        abs(dir.y) > EPS ? abs(1.0 / dir.y) : 1e30,
        abs(dir.z) > EPS ? abs(1.0 / dir.z) : 1e30
    );

    // next voxel boundary (first crossing)
    vec3 voxelBoundary = floor(origin) + vec3(step(0.0, dir.x), step(0.0, dir.y), step(0.0, dir.z));

    vec3 tMax = vec3(
        abs(dir.x) > EPS ? (voxelBoundary.x - origin.x) / dir.x : 1e30,
        abs(dir.y) > EPS ? (voxelBoundary.y - origin.y) / dir.y : 1e30,
        abs(dir.z) > EPS ? (voxelBoundary.z - origin.z) / dir.z : 1e30
    );

    int startIndex = getVoxelIndex(mapPos);

    // DDA: step first then test the new voxel so we can compute the exact hit t & normal
    for (int i = 0; i < 1024; ++i) {
        // choose axis to step
        int axis = 0;
        if (tMax.x < tMax.y) {
            axis = (tMax.x < tMax.z) ? 0 : 2;
        } else {
            axis = (tMax.y < tMax.z) ? 1 : 2;
        }

        float tHit = 0.0;
        if (axis == 0) {
            mapPos.x += stepSign.x;
            tHit = tMax.x;
            tMax.x += tDelta.x;
        } else if (axis == 1) {
            mapPos.y += stepSign.y;
            tHit = tMax.y;
            tMax.y += tDelta.y;
        } else {
            mapPos.z += stepSign.z;
            tHit = tMax.z;
            tMax.z += tDelta.z;
        }

        // test the voxel we just entered
        int currentIndex = getVoxelIndex(mapPos);
        prevMapPos = mapPos - stepSign * ((axis==0) ? ivec3(1,0,0) : (axis==1 ? ivec3(0,1,0) : ivec3(0,0,1)));
        int prevIndex = getVoxelIndex(prevMapPos);
        if (currentIndex >= 0) {
            float currentRefrac = voxels[currentIndex].voxel.refraction <= 0.0 ? 1.0 : voxels[currentIndex].voxel.refraction;
            float prevRefrac = thisRay.IOF <= 0.0 ? 1.0 : thisRay.IOF;

            float currentAlpha = currentIndex >= 0 ? rgbaColor(voxels[currentIndex].color).a : 0.0;
            float prevAlpha = prevIndex >= 0 ? rgbaColor(voxels[prevIndex].color).a : 0.0;

            bool refracChanged = abs(currentRefrac - prevRefrac) > 1e-4;
            bool occupancyChanged = (currentAlpha > 0.0 && prevAlpha <= 0.0) || (currentAlpha <= 0.0 && prevAlpha > 0.0);

            if (refracChanged && tHit > 1e-5) {
                hitMapPos = mapPos;
                // precise hit point in world-space
                hitPoint = origin + dir * tHit;
                // normal points opposite to the step (faces toward previous cell)
                if (axis == 0) hitNormal = vec3(-float(stepSign.x), 0.0, 0.0);
                else if (axis == 1) hitNormal = vec3(0.0, -float(stepSign.y), 0.0);
                else hitNormal = vec3(0.0, 0.0, -float(stepSign.z));
                return true;
            }
        }
    }

    return false;
}

vec4 raymarching_fromDir(vec3 rayOrigin, vec3 rayDir) {
    vec4 finalColor = vec4(0.0);

    ivec3 thisMapPos = ivec3(floor(rayOrigin));
    int thisVoxelIndex = getVoxelIndex(thisMapPos);
    float startIOF = 1.0; // valor default para fora (ar)
    if (thisVoxelIndex >= 0) startIOF = voxels[thisVoxelIndex].voxel.refraction;

    Ray rayStack[MAX_RAYS];
    Ray resultRays[MAX_RAYS];
    for (int i = 0; i < MAX_RAYS; ++i){
        rayStack[i].defined = false;
        resultRays[i].defined = false; // initialize result buffer to avoid garbage reads/crash
        resultRays[i].weight = 0.0;
        resultRays[i].color = vec4(0.0);
    }

    rayStack[0].origin = rayOrigin;
    rayStack[0].direction = normalize(rayDir);
    rayStack[0].IOF = startIOF;
    rayStack[0].defined = true;
    rayStack[0].weight = 1.0;
    int stackSize = 1;
    int resultSize = 0;

    vec4 firstColor;
    int counter = 0;

    while (stackSize > 0) {
        counter++;
        int rayIndex = stackSize - 1;
        Ray currentRay = rayStack[rayIndex];
        popRay(rayStack, stackSize);

        if (!currentRay.defined) continue;

        ivec3 mapPos;
        ivec3 prevMapPos;
        vec3 hitPoint;
        vec3 hitNormal;
        bool hit = hitMarching(currentRay, mapPos, prevMapPos, hitPoint, hitNormal);

        if (!hit) {
            Ray finalRay;
            finalRay.defined = true;
            finalRay.weight = currentRay.weight;
            finalRay.color = skyColor;
            addRay(resultRays, finalRay, resultSize);
            continue;
        }

        int index = getVoxelIndex(mapPos);
        VoxelObj thisVoxel;
        vec4 voxelColor;

        if (index >= 0) {
            thisVoxel = voxels[index];
            voxelColor = rgbaColor(thisVoxel.color);
        } else {
            thisVoxel.coord = ivec3(0);
            thisVoxel.color = 0u;
            thisVoxel.voxel.refraction = 1.0;
            thisVoxel.voxel.emmission = 0.0;
            thisVoxel.voxel.mettalicity = 0.0;
            thisVoxel.padding = 0.0;
            voxelColor = vec4(0.0);
        }

        int prevIndex = getVoxelIndex(prevMapPos);
        VoxelObj lastVoxel;
        vec4 lastVoxelColor;

        if (prevIndex >= 0) {
            lastVoxel = voxels[prevIndex];
            lastVoxelColor = rgbaColor(lastVoxel.color);
        } else {
            lastVoxel.coord = ivec3(0);
            lastVoxel.color = 0u;
            lastVoxel.voxel.refraction = currentRay.IOF > 0.0 ? currentRay.IOF : 1.0;
            lastVoxel.voxel.emmission = 0.0;
            lastVoxel.voxel.mettalicity = 0.0;
            lastVoxel.padding = 0.0;
            lastVoxelColor = vec4(0.0);
        }

        vec3 normal = hitNormal;
        if (length(normal) == 0.0) normal = vec3(0.0, 1.0, 0.0);

        vec3 lightDir = normalize(vec3(0.4, 1.0, 0.4));
        vec3 rayContact = hitPoint;

        float ambientStrength = 0.2;
        vec3 ambient = vec3(ambientStrength);

        float diff = max(dot(normal, lightDir), 0.0);
        vec3 diffuse = vec3(diff);

        // Shadow check
        Ray lightRay;
        lightRay.origin = rayContact + normal * 1e-3;
        lightRay.direction = lightDir;
        lightRay.IOF = currentRay.IOF;
        lightRay.defined = true;

        ivec3 shadowHit, shadowPrev;
        vec3 shadowPoint, shadowNormal;
        if (hitMarching(lightRay, shadowHit, shadowPrev, shadowPoint, shadowNormal)) {
            diffuse = vec3(0.0);
        }

        vec3 finalLight = ambient + diffuse;
        vec4 corLocal = vec4(voxelColor.rgb * finalLight, voxelColor.a);

        if(counter == 1 && voxelColor.a > 0.0){
            firstColor = corLocal;
        }
        else if(counter == 1 && lastVoxelColor.a > 0.0){
            firstColor = vec4(lastVoxelColor.rgb * finalLight, lastVoxelColor.a);
        }

        float refracIndex = thisVoxel.voxel.refraction;
        float prevRefracIndex = lastVoxel.voxel.refraction;

        if (refracIndex <= 0.0) refracIndex = 1.0;
        if (prevRefracIndex <= 0.0) prevRefracIndex = 1.0;

        vec3 incidentDir = normalize(currentRay.direction);
        vec3 n = normal;

        // === REFLECTIVE / REFRACTIVE SURFACES ===
        if (voxelColor.a < 1.0 && lastVoxelColor.a < 1.0) {
            float cosi = dot(incidentDir, n);
            float n1 = prevRefracIndex;
            float n2 = refracIndex;
            if (cosi > 0.0) {
                n = -n;
                float tmp = n1;
                n1 = n2;
                n2 = tmp;
            }
            float eta = n1 / n2;
            vec3 refractDir = refract(incidentDir, n, eta);
            vec3 reflectDir = reflect(incidentDir, n);

            float R0 = pow((n1 - n2) / (n1 + n2), 2.0);
            float cosTheta = max(0.0, dot(-incidentDir, normal));
            float reflectIntensity = R0 + (1.0 - R0) * pow(1.0 - cosTheta, 5.0);
            reflectIntensity = clamp(reflectIntensity, 0.0, 1.0);

            float refractIntensity = 1.0 - reflectIntensity;

            // ---- Reflection ray (safe add) ----
            if (reflectIntensity > 0.01 && stackSize < MAX_RAYS) {
                Ray reflectionRay;
                reflectionRay.direction = reflectDir;
                reflectionRay.origin = rayContact + normal * 1e-4;
                reflectionRay.defined = true;
                reflectionRay.IOF = prevRefracIndex;
                reflectionRay.weight = currentRay.weight * reflectIntensity;
                if (reflectionRay.weight > 1e-4)
                    addRay(rayStack, reflectionRay, stackSize);
            }

            // ---- Refraction ray (safe add) ----
            if (refractIntensity > 0.01 && stackSize < MAX_RAYS) {
                Ray refractionRay;
                refractionRay.direction = refractDir;
                refractionRay.origin = rayContact - normal * 1e-4;
                refractionRay.defined = true;
                refractionRay.IOF = refracIndex;
                refractionRay.weight = currentRay.weight * refractIntensity;
                if (refractionRay.weight > 1e-4)
                    addRay(rayStack, refractionRay, stackSize);
            }
        }
        else {
            // === OPAQUE SURFACE ===
            float specularFactor = thisVoxel.voxel.mettalicity;
            float diffuseFactor = 1.0 - specularFactor;

            // Diffuse component
            if (diffuseFactor > 0.01) {
                Ray finalRay;
                finalRay.defined = true;
                finalRay.weight = currentRay.weight * diffuseFactor;
                finalRay.color = corLocal;
                addRay(resultRays, finalRay, resultSize);
            }

            // Specular reflection (safe add)
            if (specularFactor > 0.01 && stackSize < MAX_RAYS) {
                vec3 reflectDir = reflect(incidentDir, normal);
                Ray reflectionRay;
                reflectionRay.direction = reflectDir;
                reflectionRay.origin = rayContact + normal * 1e-4;
                reflectionRay.defined = true;
                reflectionRay.IOF = prevRefracIndex;
                reflectionRay.weight = currentRay.weight * specularFactor;
                if (reflectionRay.weight > 1e-4)
                    addRay(rayStack, reflectionRay, stackSize);
            }
        }
    }
    
    return accumulateColors(resultRays, firstColor);
}

void main() {
    ivec2 pixel_coords = ivec2(gl_GlobalInvocationID.xy);
    ivec2 dims = imageSize(destTex);

    if (pixel_coords.x < 0 || pixel_coords.x >= dims.x || pixel_coords.y < 0 || pixel_coords.y >= dims.y) return;

    float u = (float(pixel_coords.x) / float(dims.x)) * 2.0 - 1.0;
    float v = (float(pixel_coords.y) / float(dims.y)) * 2.0 - 1.0;

    // Geração correta do raio: NDC -> view -> world
    vec4 clip = vec4(u, v, -1.0, 1.0); // z = -1 (near plane)
    vec4 view = invProjection * clip;
    // divide por w para obter coordenada em view space
    if (abs(view.w) > 1e-6) view /= view.w;
    vec3 viewDir = normalize(view.xyz);
    vec3 worldDir = normalize((invView * vec4(viewDir, 0.0)).xyz);

    vec4 finalColor = raymarching_fromDir(cameraPos, worldDir);

    if (length(finalColor.rgb) == 0.0) finalColor = skyColor;

    imageStore(destTex, pixel_coords, finalColor);
}