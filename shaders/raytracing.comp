#version 450 core
 
#define LEAF_FLAG 255u 
#define INTERNAL_NODE_FLAG 0u

// A dimensão da sua folha em texels (baseado no seu C++)
#define LEAF_SIZE 3

const int MAX_RAYS = 8;
const vec4 skyColor = vec4(0.5, 0.7, 1.0, 1.0);

layout (local_size_x = 8, local_size_y = 8, local_size_z = 1) in;
layout (rgba8, binding = 0) uniform writeonly image2D destTex;

layout (std140, binding = 1) uniform Camera {
    mat4 invProjection;
    mat4 invView;
    vec4 cameraPos;
};

layout (binding = 2) uniform usampler3D u_octreeTexture;
layout (rg32i, binding = 3) uniform writeonly iimage2D voxelIDTex;

// A dimensão da sua textura (ex: 256.0 para uma textura 256x256x256)
uniform int u_texDim;

uniform float u_voxelScale; // A escala do voxel no mundo, ex: 2.0 significa 1 voxel a cada 0.5 unidades de espaço

// Os cantos min/max do volume total da sua octree no espaço do mundo
uniform ivec3 u_worldBoundsMin;
uniform ivec3 u_worldBoundsMax;
ivec3 worldSize = u_worldBoundsMax - u_worldBoundsMin;

uniform vec4 globalLight;
uniform vec3 lightDir;

uniform ivec3 u_highlightedVoxel;

/*
 * Estrutura de Retorno
 * Contém os dados do voxel que encontramos.
 */
struct VoxelData {
    lowp vec4 color;       // Cor (RGBA)
    lowp vec3 properties;  // Refração, Iluminação, K
    mediump ivec3 nodeMin;
    mediump ivec3 nodeMax;
    mediump ivec3 nodeCoord;
};

/*
 * Estrutura de Raio
 * Usada para rastreamento de raios.
 */
struct Ray {
    mediump vec3 origin;
    mediump vec3 direction;
    mediump float IOF;
    mediump float weight;
    bool defined;
    lowp vec4 colorTint;
    mediump float distanceInMedium;
    lowp vec4 mediumColor;
    lowp float mediumDensity;
    int depth;
};

/*
 * Funções Auxiliares
 */

// Converte uma coordenada 3D em um índice linear 1D
int toLinear(ivec3 coord) {
    return coord.x + u_texDim * (coord.y + u_texDim * coord.z);
}

// Converte um índice linear 1D de volta para uma coordenada 3D
ivec3 fromLinear(int index) {
    int tex_dim_sq = u_texDim * u_texDim;
    int z = index / tex_dim_sq;
    int rem = index - z * tex_dim_sq;
    return ivec3(rem - (rem / u_texDim) * u_texDim, rem / u_texDim, z);
}

// Converte um "ponteiro" (cor RGB 0.0-1.0) de volta para 
// uma coordenada inteira de texel (ex: [0, 255])
ivec3 decodePointer(uvec3 pointer_rgb) {
    // Os valores já são os inteiros corretos (0-255)
    return ivec3(pointer_rgb);
}

// Determina em qual filho (0-7) o voxel do mundo está
int getchildIndices(ivec3 worldPos, ivec3 nodeMidPoint) {
    // O ponto médio calculado por divisão de inteiros é o INÍCIO do bloco da direita.
    bvec3 greater = greaterThanEqual(worldPos, nodeMidPoint);
    return int(greater.x) * 4 + int(greater.y) * 2 + int(greater.z);
}

void getChildBounds(int childIndices, inout ivec3 nodeMin, inout ivec3 nodeMax) {
    ivec3 mid = nodeMin + (nodeMax - nodeMin) / 2; // half split

    // Se o bit estiver set => este child é o "lado alto" => min = mid, max = old max
    // Caso contrário => este child é o "lado baixo" => min = old min, max = mid
    nodeMin.x = ((childIndices & 4) != 0) ? mid.x : nodeMin.x;
    nodeMax.x = ((childIndices & 4) != 0) ? nodeMax.x : mid.x;

    nodeMin.y = ((childIndices & 2) != 0) ? mid.y : nodeMin.y;
    nodeMax.y = ((childIndices & 2) != 0) ? nodeMax.y : mid.y;

    nodeMin.z = ((childIndices & 1) != 0) ? mid.z : nodeMin.z;
    nodeMax.z = ((childIndices & 1) != 0) ? nodeMax.z : mid.z;
}

// Converte os dados de propriedade (armazenados como 0-255) de volta
// para os valores float originais.
vec3 decodeProperties(vec4 texel) {
    return vec3(texel.r * 3.0, texel.g, texel.b);
}

// Obtém o texel de dados de um nó. 
// texelFetch usa coordenadas inteiras (ivec3).
uvec4 getNodeData(ivec3 coord) {
    // texelFetch em usampler3D retorna uvec4 com os valores exatos (0-255)
    return texelFetch(u_octreeTexture, coord, 0);
}

VoxelData octreeFind(ivec3 worldPos, inout ivec3 minBound, inout ivec3 maxBound, inout ivec3 currentNodeCoord) {
    VoxelData data;
    data.color = vec4(0.0);
    data.properties = vec3(0.0);

    // Mantenha suas verificações de borda (u_worldBoundsMin/Max) aqui...
    if (any(lessThan(worldPos, u_worldBoundsMin)) || any(greaterThanEqual(worldPos, u_worldBoundsMax))) {
       return data;
    }

    // Se a posição estiver dentro do mesmo node da intersecção anterior, continua da busca dele
    // senão volta a busca da raiz da octree
    bool isInside = all(greaterThanEqual(worldPos, minBound)) && 
                    all(lessThan(worldPos, maxBound));
    
    int mask = int(isInside);       // 1 se dentro, 0 se fora
    int invMask = 1 - mask;         // 0 se dentro, 1 se fora

    data.nodeCoord = currentNodeCoord * mask; // (x * 1) ou (x * 0)
    data.nodeMin = (minBound * mask) + (u_worldBoundsMin * invMask);
    data.nodeMax = (maxBound * mask) + (u_worldBoundsMax * invMask);
    
    for (int i = 0; i < 16; i++) {
        // LEITURA DIRETA DE INTEIROS
        uvec4 nodeData = getNodeData(data.nodeCoord); 

        // Comparação direta de inteiros (>= 255u)
        if (nodeData.a >= LEAF_FLAG) {            
            int linearIndex = toLinear(data.nodeCoord);

            // Lê Propriedades
            ivec3 propTexelCoord = fromLinear(linearIndex + 1);
            uvec4 propData = getNodeData(propTexelCoord);

            data.color.rgb = vec3(nodeData.rgb) / 255.0;
            data.color.a = float(propData.a) / 255.0;
            
            // decodeProperties original esperava vec4 float. Adaptamos:
            vec4 propDataFloat = vec4(propData) / 255.0;
            data.properties = decodeProperties(propDataFloat);
            return data;
        }

        // Nó Interno
        if (nodeData.a <= INTERNAL_NODE_FLAG) {
            // Pega ponteiro direto (sem conversão de cor)
            ivec3 pointerBlockBaseCoord = decodePointer(nodeData.rgb);
            ivec3 midPoint = data.nodeMin + ((data.nodeMax - data.nodeMin) >> 1);
            int childIndices = getchildIndices(worldPos, midPoint);
            
            int linearBaseIndex = toLinear(pointerBlockBaseCoord);
            ivec3 childPointerCoord = fromLinear(linearBaseIndex + childIndices);
            
            uvec4 childPointerData = getNodeData(childPointerCoord);
            ivec3 nextNode = decodePointer(childPointerData.rgb);

            // Guarda as informações do nó pai
            currentNodeCoord = data.nodeCoord;
            minBound = data.nodeMin;
            maxBound = data.nodeMax;

            data.nodeCoord = nextNode;
            getChildBounds(childIndices, data.nodeMin, data.nodeMax);

            if (all(equal(nextNode, ivec3(0)))) {
                data.color = vec4(0.0); // Mark as empty
                return data;
            }
            
            continue;
        }
        return data;
    }
    return data;
}

// --- Raymarching ---

bool isInsideWorld(ivec3 c) {
    return all(greaterThanEqual(c, u_worldBoundsMin)) && all(lessThan(c, u_worldBoundsMax));
}

bool addRay(inout Ray rays[MAX_RAYS], Ray ray, inout int stackSize) {
    if (!ray.defined || stackSize >= MAX_RAYS) return false;
    rays[stackSize++] = ray;
    return true;
}


vec4 accumulateColors(Ray rays[MAX_RAYS], int rayCount) {
    vec3 result = vec3(0.0);
    float totalWeight = 0.0;
    
    // OTIMIZADO: Loop unrolling manual para MAX_RAYS=8
    for(int i = 0; i < rayCount; ++i){
        if (rays[i].defined){
            result += rays[i].colorTint.rgb * rays[i].weight;
        }
    }

    return vec4(result, 1.0);
}

bool hitMarching(vec3 rayOrigin, vec3 rayDir, float rayIOF, out ivec3 hitMapPos, out vec3 hitPoint, out vec3 hitNormal, out VoxelData prevVoxel, out VoxelData hitVoxel) {
    
    vec3 rayPos = rayOrigin;
    float invLen = inversesqrt(dot(rayDir, rayDir));
    rayDir *= invLen;

    // Epsilon pequeno para cruzar a fronteira
    const float DIR_EPSILON = 1e-8;
    const float EPS = 0.0001;
    
    // Evita divisão por zero
    vec3 invDir;
    invDir.x = (abs(rayDir.x) < DIR_EPSILON) ? 1e20 : 1.0 / rayDir.x;
    invDir.y = (abs(rayDir.y) < DIR_EPSILON) ? 1e20 : 1.0 / rayDir.y;
    invDir.z = (abs(rayDir.z) < DIR_EPSILON) ? 1e20 : 1.0 / rayDir.z;


    // Começa a procurar o voxel da root
    ivec3 currentNodeCoord = ivec3(0);
    ivec3 nodeMin = u_worldBoundsMin;
    ivec3 nodeMax = u_worldBoundsMax;
    // Pega o estado inicial
    ivec3 mapPos = ivec3(floor(rayPos));
    hitVoxel = octreeFind(mapPos, nodeMin, nodeMax, currentNodeCoord);
    
    // Inicializa prevVoxel na primeira iteração
    prevVoxel = hitVoxel;
    
    // Define um limite de segurança para o loop
    for (int i = 0; i < 1024; ++i) {
        vec3 boxMin = vec3(hitVoxel.nodeMin);
        vec3 boxMax = vec3(hitVoxel.nodeMax);

        vec3 tPlane;
        tPlane.x = (rayDir.x > 0.0 ? boxMax.x : boxMin.x) - rayPos.x;
        tPlane.y = (rayDir.y > 0.0 ? boxMax.y : boxMin.y) - rayPos.y;
        tPlane.z = (rayDir.z > 0.0 ? boxMax.z : boxMin.z) - rayPos.z;

        // Tempo/Distância até as paredes
        vec3 tMax = tPlane * invDir;
        
        // 3. Descubra qual face atingimos primeiro (o menor t)
        // Isso nos dá a NORMAL e a distância do passo.
        float tStep = min(tMax.x, min(tMax.y, tMax.z));
        int axis = (tMax.x < tMax.y) ? ((tMax.x < tMax.z) ? 0 : 2) : ((tMax.y < tMax.z) ? 1 : 2);
        hitNormal = vec3(0.0);
        hitNormal[axis] = -sign(rayDir[axis]);
        
        // Avança o raio para EXATAMENTE a borda
        // Nota: O 'tStep' é a distância geométrica exata até a parede.
        rayPos += rayDir * tStep;

        vec3 stepDir = sign(rayDir);

        // Se o raio for perfeitamente alinhado, a matemática acima é segura.
        // Mas para garantir que cruzamos a face no eixo correto:
        rayPos[axis] += stepDir[axis] * EPS;

        // Recalcula mapPos baseado no ponto levemente penetrado
        mapPos = ivec3(floor(rayPos));
        
        // Verifica se saiu do mundo
        if (!isInsideWorld(mapPos)) return false;

        // Salva o estado anterior antes de atualizar
        prevVoxel = hitVoxel;
        // Busca o NOVO voxel na nova posição
        hitVoxel = octreeFind(mapPos, nodeMin, nodeMax, currentNodeCoord);
        
        // 5. Verifica mudança de meio (lógica de Hit)
        float prevRefrac = (prevVoxel.color.a > 0.0 && prevVoxel.properties[0] > 0.0) ? prevVoxel.properties[0] : rayIOF;
        float currentRefrac = (hitVoxel.color.a > 0.0 && hitVoxel.properties[0] > 0.0) ? hitVoxel.properties[0] : 1.0;

        if (abs(currentRefrac - prevRefrac) > EPS) {
            hitMapPos = mapPos;
            // O ponto de hit exato é a posição atual (que está na borda)
            hitPoint = rayPos;
            return true;
        }
    }
    
    return false;
}

// Simplified raymarch just for occlusion
bool inShadow(vec3 origin, vec3 lightDir) {
    vec3 rayPos = origin;

    const float DIR_EPSILON = 1e-8;
    const float EPS = 0.001;

    vec3 invDir;
    invDir.x = (abs(lightDir.x) < DIR_EPSILON) ? 1e20 : 1.0 / lightDir.x;
    invDir.y = (abs(lightDir.y) < DIR_EPSILON) ? 1e20 : 1.0 / lightDir.y;
    invDir.z = (abs(lightDir.z) < DIR_EPSILON) ? 1e20 : 1.0 / lightDir.z;

    ivec3 mapPos = ivec3(floor(rayPos));
    VoxelData vox;

    // Começa a procurar o voxel da root
    ivec3 currentNodeCoord = ivec3(0);
    ivec3 nodeMin = u_worldBoundsMin;
    ivec3 nodeMax = u_worldBoundsMax;

    for (int i = 0; i < 64; ++i) {
        vox = octreeFind(mapPos, nodeMin, nodeMax, currentNodeCoord);
        
        if (vox.color.a > 0.1) return true;

        vec3 boxMin = vec3(vox.nodeMin);
        vec3 boxMax = vec3(vox.nodeMax);

        vec3 tPlane;
        tPlane.x = (lightDir.x > 0.0 ? boxMax.x : boxMin.x) - rayPos.x;
        tPlane.y = (lightDir.y > 0.0 ? boxMax.y : boxMin.y) - rayPos.y;
        tPlane.z = (lightDir.z > 0.0 ? boxMax.z : boxMin.z) - rayPos.z;

        // Tempo/Distância até as paredes
        vec3 tMax = tPlane * invDir;
        float tStep = min(tMax.x, min(tMax.y, tMax.z));
        int axis = (tMax.x < tMax.y) ? ((tMax.x < tMax.z) ? 0 : 2) : ((tMax.y < tMax.z) ? 1 : 2);
        
        rayPos += lightDir * tStep;
        rayPos[axis] += sign(lightDir[axis]) * EPS;
        mapPos = ivec3(floor(rayPos));

        if (!isInsideWorld(mapPos)) return false;
    }
    return false;
}

uint rngState;

void initRNG(ivec2 pixelCoord, int sampleIndex) {
    // Better seed mixing for stratified samples
    uint seed = uint(pixelCoord.x) + uint(pixelCoord.y) * 1920u + 
                uint(0) * 123456u + uint(sampleIndex) * 78901u;
    rngState = seed * 747796405u + 2891336453u;
    uint word = ((rngState >> ((rngState >> 28u) + 4u)) ^ rngState) * 277803737u;
    rngState = (word >> 22u) ^ word;
}

float rand() {
    rngState = rngState * 747796405u + 2891336453u;
    uint word = ((rngState >> ((rngState >> 28u) + 4u)) ^ rngState) * 277803737u;
    rngState = (word >> 22u) ^ word;
    return float(rngState) / 4294967296.0;
}

vec2 rand2() { 
    return vec2(rand(), rand()); 
}

// ===== STRATIFIED SAMPLING =====
// Divides pixel into grid for better coverage
vec2 stratifiedSample(int sampleIndex, int totalSamples) {
    int sqrtSamples = int(ceil(sqrt(float(totalSamples))));
    int x = sampleIndex % sqrtSamples;
    int y = sampleIndex / sqrtSamples;
    
    vec2 jitter = rand2();
    vec2 stratified = (vec2(x, y) + jitter) / float(sqrtSamples);
    return stratified;
}

// ===== IMPORTANCE SAMPLING =====
vec3 cosineSampleHemisphere(vec3 normal) {
    vec2 r = rand2();
    float phi = 2.0 * 3.14159265359 * r.x;
    float cosTheta = sqrt(r.y);
    float sinTheta = sqrt(1.0 - r.y);
    
    vec3 up = abs(normal.z) < 0.999 ? vec3(0, 0, 1) : vec3(1, 0, 0);
    vec3 tangent = normalize(cross(up, normal));
    vec3 bitangent = cross(normal, tangent);
    
    return normalize(tangent * (sinTheta * cos(phi)) + 
                     bitangent * (sinTheta * sin(phi)) + 
                     normal * cosTheta);
}

int getFaceIndex(vec3 normal) {
    // Evita problemas com normais (0,0,0) ou mal normalizadas
    if (length(normal) < 0.5) return 0;
    
    vec3 absNorm = abs(normal);
    
    // Testa qual eixo é o predominante (X, Y ou Z)
    if (absNorm.x > absNorm.y && absNorm.x > absNorm.z) {
        return normal.x > 0.0 ? 0 : 1; // +X ou -X
    } else if (absNorm.y > absNorm.z) {
        return normal.y > 0.0 ? 2 : 3; // +Y ou -Y
    } else {
        return normal.z > 0.0 ? 4 : 5; // +Z ou -Z
    }
}

vec4 pathTrace(vec3 rayOrigin, vec3 rayDir, inout int primaryVoxelID, inout int pixelDist) {
    ivec3 currentNodeCoord = ivec3(0);
    ivec3 nodeMin = u_worldBoundsMin;
    ivec3 nodeMax = u_worldBoundsMax;

    primaryVoxelID = -1;
    pixelDist = worldSize.x;

    vec3 gridRayOrigin = rayOrigin * u_voxelScale;

    ivec3 thisMapPos = ivec3(floor(gridRayOrigin));
    VoxelData thisVoxel = octreeFind(thisMapPos, nodeMin, nodeMax, currentNodeCoord);

    float startIOF = (thisVoxel.properties[0] > 0.0 && thisVoxel.properties[0] < 3.0) 
                      ? thisVoxel.properties[0] : 1.0;

    Ray rayStack[MAX_RAYS];
    for (int i = 0; i < MAX_RAYS; ++i) {
        rayStack[i].defined = false;
    }

    float invLen = inversesqrt(dot(rayDir, rayDir));
    rayDir = rayDir * invLen;
    rayStack[0] = Ray(
        gridRayOrigin, rayDir, startIOF, 1.0, true, globalLight, 0.0,
        thisVoxel.color.a > 0.0 ? thisVoxel.color : vec4(1.0),
        thisVoxel.color.a * 5.0, 0
    );
    int stackSize = 1;

    vec3 finalColor = vec3(0.0);

    while (stackSize > 0) {
        Ray currentRay = rayStack[--stackSize];
        rayStack[stackSize].defined = false;
        
        if (!currentRay.defined) continue;

        ivec3 mapPos;
        vec3 hitPoint, hitNormal;
        VoxelData lastVoxel, hitVoxel;
        
        bool hit = hitMarching(currentRay.origin, currentRay.direction, currentRay.IOF,
                              mapPos, hitPoint, hitNormal, lastVoxel, hitVoxel);

        if (!hit) {
            // Apply Beer's Law and add to results
            vec4 transmittedColor = currentRay.colorTint;
            if (currentRay.distanceInMedium > 1e-6 && currentRay.mediumDensity > 0.0) {
                vec3 absorption = exp(-currentRay.mediumDensity * currentRay.distanceInMedium * 
                                      (vec3(1.0) - currentRay.mediumColor.rgb));
                transmittedColor.rgb *= absorption;
            }

            finalColor += transmittedColor.rgb * currentRay.weight;
            continue;
        }

        vec3 normal = length(hitNormal) > 0.0 ? hitNormal : vec3(0.0, 1.0, 0.0);

        vec3 hitPointWorld = hitPoint / u_voxelScale;
        // Adiciona metade do tamanho na direção da normal para chegar ao centro da FACE
        vec3 faceCenterGrid = vec3(mapPos) + normal;

        // Update distance traveled through current medium
        currentRay.distanceInMedium += length(hitPointWorld - currentRay.origin) / u_voxelScale;
        
        if (hitVoxel.color.a <= 0.0) hitVoxel.properties = vec3(1.0, 0.0, 0.0);
        if (lastVoxel.color.a <= 0.0) lastVoxel.properties = currentRay.IOF > 0.0 ? vec3(0.0) : vec3(1.0, 0.0, 0.0);

        vec3 finalLight = vec3(max(dot(normal, lightDir), 0.0));
        
        // Determine surface color based on which side we're hitting
        vec4 surfaceColor = hitVoxel.color.a > 0.0 ? hitVoxel.color : lastVoxel.color;
        float n2 = hitVoxel.properties[0] > 0.0 ? hitVoxel.properties[0] : 1.0;
        float n1 = lastVoxel.properties[0] > 0.0 ? lastVoxel.properties[0] : 1.0;

        vec3 incidentDir = currentRay.direction;

        // Apply Beer's Law
        vec4 transmittedColor = currentRay.colorTint;
        if (currentRay.distanceInMedium > 1e-6 && currentRay.mediumDensity > 0.0) {
            vec3 absorption = exp(-currentRay.mediumDensity * currentRay.distanceInMedium * 
                                  (vec3(1.0) - currentRay.mediumColor.rgb));
            transmittedColor.rgb *= absorption;
        }

        if(mapPos == u_highlightedVoxel){
            surfaceColor = vec4(vec3(1.0) - surfaceColor.rgb, 1.0);
        } 

        // === TRANSPARENT/TRANSLUCENT SURFACES ===
        float cosi = dot(incidentDir, normal);
        if (cosi > 0.0) {
            normal = -normal;
            float tmp = n1; n1 = n2; n2 = tmp;
        }

        vec3 refractDir = refract(incidentDir, normal, n1 / n2);

        float R0 = (n1 - n2) / (n1 + n2) * (n1 - n2) / (n1 + n2);
        float cosTheta = max(0.0, dot(-incidentDir, normal));
        float fresnel = clamp(R0 + (1.0 - R0) * pow(1.0 - cosTheta, 5.0), 0.0, 1.0);

        bool hasTIR = length(refractDir) < 0.001;
        float reflectIntensity = fresnel;
        float refractIntensity = hasTIR ? 0.0 : (1.0 - fresnel);

        if (currentRay.depth == 0 && primaryVoxelID == -1 && surfaceColor.a >= 1) {
            int voxelIndex = toLinear(mapPos);
            int faceIndex = getFaceIndex(hitNormal);
            
            // Cria um ID único para ESTA FACE deste voxel específico.
            // Multiplicamos por 6 para "abrir espaço" para as 6 faces possíveis.
            primaryVoxelID = (voxelIndex * 6) + faceIndex;
            pixelDist = int(length(hitPointWorld - rayOrigin));
        }

        if (currentRay.depth <= 0 && surfaceColor.a < 1) {
            // DONT WASTE ENERGY YOU SICK FUCK
            if(stackSize == MAX_RAYS || reflectIntensity <= 0.001 || refractIntensity <= 0.001){
                vec4 litSurfaceColor = vec4(surfaceColor.rgb * finalLight, 1.0);
                finalColor += transmittedColor.rgb * litSurfaceColor.rgb * currentRay.weight;
                continue;
            }

            // ---- Reflection ray ----
            if (reflectIntensity > 0.001 && stackSize < MAX_RAYS) {
                float reflectWeight = currentRay.weight * reflectIntensity;
                if (reflectWeight > 1e-4)
                    rayStack[stackSize++] = Ray(
                        hitPoint + normal * 1e-4, reflect(incidentDir, normal), n1,
                        reflectWeight, true,
                        transmittedColor, 0.0, lastVoxel.color, lastVoxel.color.a * 5.0, currentRay.depth
                    );
            }

            // ---- Refraction ray ----
            if (refractIntensity > 0.001 && stackSize < MAX_RAYS && !hasTIR) {
                rayStack[stackSize++] = Ray(
                    hitPoint - normal * 1e-4, refractDir, n2,
                    currentRay.weight * refractIntensity, true,
                    transmittedColor, 0.0, hitVoxel.color, hitVoxel.color.a * 5.0, currentRay.depth
                );
            }
        }
        else {
            // === PATH TRACING: SUPERFÍCIE OPACA ===
            
            // 1. Iluminação Direta (Next Event Estimation)
            // Calculamos a luz do sol AGORA e somamos ao resultado final.
            float ndotl = max(dot(normal, lightDir), 0.0);
            
            // Sombra (Raytrace real)
            // Nota: Use um shadowRay simples aqui se tiver, ou sua função inShadow
            float shadowFactor = 1.0;
            if (ndotl > 0.0) {
                 // Pequeno bias (1e-3) para evitar "acne" de sombra
                 bool isInShadow = inShadow(hitPoint + normal * 2e-3, lightDir); 
                 shadowFactor = isInShadow ? 0.0 : 1.0;
            }

            vec3 directLight = globalLight.rgb * ndotl * shadowFactor;

            // A MÁGICA: Somamos a luz direta ponderada pela "tinta" (throughput) que o raio carrega
            // Se este é o primeiro raio, weight é 1.0. Se é o segundo, weight é a cor da parede anterior.
            vec3 lightingContribution = directLight * surfaceColor.rgb * transmittedColor.rgb * currentRay.weight;
            finalColor += lightingContribution;

            // 2. Iluminação Indireta (O Rebote)
            // O que sobrou da luz (que não foi absorvida) continua viajando
            
            // Probabilidade de reflexão especular vs difusa (Fresnel simplificado)
            float specularProb = hitVoxel.properties[2]; // Metallicity ou Specular

            // Russian Roulette
            float russianRoulette = max(max(surfaceColor.r, surfaceColor.g), surfaceColor.b) * currentRay.weight;
            if (currentRay.depth >= 2 || russianRoulette < 0.1) {
                if (rand() > russianRoulette) continue;
            }
            
            // Russian Roulette: Mata o raio se ele estiver muito fraco para economizar performance
            // Aumenta a chance de morrer conforme o 'weight' diminui
            if (currentRay.depth < 3 && stackSize < MAX_RAYS) { // Limite de 3 batidas
                vec3 bounceDir;
                float newWeight = currentRay.weight;
                // Reflexão Difusa (Espalha luz em todas as direções)
                // Usa amostragem cosseno para convergir mais rápido sem ruído
                // Decide se é especular ou difuso baseado em probabilidade
                bool isSpecular = (rand() < specularProb); 

                if (isSpecular) {
                    // Reflexão Perfeita (Espelho)
                    bounceDir = reflect(incidentDir, normal);
                } else {
                    // Reflexão Difusa (Espalha luz em todas as direções)
                    // Usa amostragem cosseno para convergir mais rápido sem ruído
                    bounceDir = cosineSampleHemisphere(normal);
                }

                vec3 brdfFactor = vec3(0.0);
                float pdf = 1.0;

                if (isSpecular) {
                    // sample perfect reflection (delta): mirror
                    bounceDir = reflect(incidentDir, normal);
                    // throughput multiply by Fresnel (energy kept in delta)
                    brdfFactor = vec3(1.0) * reflectIntensity; // reflectance
                    pdf = 1.0; // delta PDF treated as 1 for our discrete branch
                } else {
                    // sample diffuse lobe (cosine-weighted)
                    bounceDir = cosineSampleHemisphere(normal);
                    // Lambertian BRDF = albedo / pi
                    brdfFactor = surfaceColor.rgb / 3.14159265;
                    // pdf for cosine hemisphere = cos(theta) / pi
                    float cosNew = max(dot(bounceDir, normal), 0.0);
                    pdf = cosNew / 3.14159265 + 1e-7;
                }

                // ATUALIZA A TINTA (THROUGHPUT)
                // Importante: Multiplicamos apenas pela COR DO VOXEL (Albedo), não pela luz.
                // O 'transmittedColor' é a tinta que o raio já trazia (ex: passou por vidro colorido)
                float cosTerm = max(dot(bounceDir, normal), 0.0);
                vec3 factor = brdfFactor * cosTerm / pdf;
                vec4 nextTint = transmittedColor * vec4(factor, 1.0);

                // Empilha o novo raio
                Ray bounceRay;
                bounceRay.origin = hitPoint + normal * 0.002; // Bias para não bater no próprio voxel
                bounceRay.direction = bounceDir;
                bounceRay.IOF = n1; // Mantém o índice de refração do meio atual
                bounceRay.weight = newWeight; // Mantém o peso (energia)
                bounceRay.defined = true;
                bounceRay.colorTint = nextTint; // A nova cor filtro
                bounceRay.distanceInMedium = 0.0;
                bounceRay.mediumColor = vec4(0.0);
                bounceRay.mediumDensity = 0.0;
                bounceRay.depth = currentRay.depth + 1; // Aumenta a contagem de bounces

                addRay(rayStack, bounceRay, stackSize);
            }
        }
    }
    
    return vec4(finalColor, 1.0);
}

void main() {
    ivec2 pixel_coords = ivec2(gl_GlobalInvocationID.xy);
    ivec2 dims = imageSize(destTex);

    if (pixel_coords.x < 0 || pixel_coords.x >= dims.x || pixel_coords.y < 0 || pixel_coords.y >= dims.y) return;
    initRNG(pixel_coords, 0);

    float u = (float(pixel_coords.x) / float(dims.x)) * 2.0 - 1.0;
    float v = (float(pixel_coords.y) / float(dims.y)) * 2.0 - 1.0;

    vec4 clip = vec4(u, v, -1.0, 1.0);
    vec4 view = invProjection * clip;
    if (abs(view.w) > 1e-6) view /= view.w;
    vec3 viewDir = normalize(view.xyz);
    vec3 worldDir = normalize((invView * vec4(viewDir, 0.0)).xyz);

    int voxelID, dist;
    vec4 finalColor = pathTrace(cameraPos.xyz, worldDir, voxelID, dist);

    imageStore(destTex, pixel_coords, finalColor);
    imageStore(voxelIDTex, pixel_coords, ivec4(voxelID, dist, 0.0, 0.0));
}