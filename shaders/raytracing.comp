#version 450 core
 
#define LEAF_FLAG 255u 
#define INTERNAL_NODE_FLAG 0u

// A dimensão da sua folha em texels (baseado no seu C++)
#define LEAF_SIZE 3

const int MAX_RAYS = 8;
const vec4 skyColor = vec4(0.5, 0.7, 1.0, 1.0);

layout (local_size_x = 8, local_size_y = 8, local_size_z = 1) in;
layout (rgba8, binding = 0) uniform writeonly image2D destTex;

layout (std140, binding = 1) uniform Camera {
    mat4 invProjection;
    mat4 invView;
    vec4 cameraPos;
};

layout (binding = 2) uniform usampler3D u_octreeTexture;

// A dimensão da sua textura (ex: 256.0 para uma textura 256x256x256)
uniform int u_texDim;

uniform float u_voxelScale; // A escala do voxel no mundo, ex: 2.0 significa 1 voxel a cada 0.5 unidades de espaço

// Os cantos min/max do volume total da sua octree no espaço do mundo
uniform ivec3 u_worldBoundsMin;
uniform ivec3 u_worldBoundsMax;
ivec3 worldSize = u_worldBoundsMax - u_worldBoundsMin;

uniform vec4 globalLight;
uniform vec3 lightDir;


/*
 * Estrutura de Retorno
 * Contém os dados do voxel que encontramos.
 */
struct VoxelData {
    lowp vec4 color;       // Cor (RGBA)
    lowp vec3 properties;  // Refração, Iluminação, K
    mediump ivec3 nodeMin;
    mediump ivec3 nodeMax;
    mediump ivec3 nodeCoord;
};

/*
 * Estrutura de Raio
 * Usada para rastreamento de raios.
 */
struct Ray {
    mediump vec3 origin;
    mediump vec3 direction;
    mediump float IOF;
    mediump float weight;
    bool defined;
    lowp vec4 colorTint;
    mediump float distanceInMedium;
    lowp vec4 mediumColor;
    lowp float mediumDensity;
};

/*
 * Funções Auxiliares
 */

// Converte uma coordenada 3D em um índice linear 1D
int toLinear(ivec3 coord) {
    return coord.x + u_texDim * (coord.y + u_texDim * coord.z);
}

// Converte um índice linear 1D de volta para uma coordenada 3D
ivec3 fromLinear(int index) {
    int tex_dim_sq = u_texDim * u_texDim;
    int z = index / tex_dim_sq;
    int rem = index - z * tex_dim_sq;
    return ivec3(rem - (rem / u_texDim) * u_texDim, rem / u_texDim, z);
}

// Converte um "ponteiro" (cor RGB 0.0-1.0) de volta para 
// uma coordenada inteira de texel (ex: [0, 255])
ivec3 decodePointer(uvec3 pointer_rgb) {
    // Os valores já são os inteiros corretos (0-255)
    return ivec3(pointer_rgb);
}

// Determina em qual filho (0-7) o voxel do mundo está
int getchildIndices(ivec3 worldPos, ivec3 nodeMidPoint) {
    // O ponto médio calculado por divisão de inteiros é o INÍCIO do bloco da direita.
    bvec3 greater = greaterThanEqual(worldPos, nodeMidPoint);
    return int(greater.x) * 4 + int(greater.y) * 2 + int(greater.z);
}

void getChildBounds(int childIndices, inout ivec3 nodeMin, inout ivec3 nodeMax) {
    ivec3 mid = nodeMin + (nodeMax - nodeMin) / 2; // half split

    // Se o bit estiver set => este child é o "lado alto" => min = mid, max = old max
    // Caso contrário => este child é o "lado baixo" => min = old min, max = mid
    nodeMin.x = ((childIndices & 4) != 0) ? mid.x : nodeMin.x;
    nodeMax.x = ((childIndices & 4) != 0) ? nodeMax.x : mid.x;

    nodeMin.y = ((childIndices & 2) != 0) ? mid.y : nodeMin.y;
    nodeMax.y = ((childIndices & 2) != 0) ? nodeMax.y : mid.y;

    nodeMin.z = ((childIndices & 1) != 0) ? mid.z : nodeMin.z;
    nodeMax.z = ((childIndices & 1) != 0) ? nodeMax.z : mid.z;
}

// Converte os dados de propriedade (armazenados como 0-255) de volta
// para os valores float originais.
vec3 decodeProperties(vec4 texel) {
    return vec3(texel.r * 3.0, texel.g, texel.b);
}

// Obtém o texel de dados de um nó. 
// texelFetch usa coordenadas inteiras (ivec3).
uvec4 getNodeData(ivec3 coord) {
    // texelFetch em usampler3D retorna uvec4 com os valores exatos (0-255)
    return texelFetch(u_octreeTexture, coord, 0);
}

VoxelData octreeFind(ivec3 worldPos, inout ivec3 minBound, inout ivec3 maxBound, inout ivec3 currentNodeCoord) {
    VoxelData data;
    data.color = vec4(0.0);
    data.properties = vec3(0.0);

    // Mantenha suas verificações de borda (u_worldBoundsMin/Max) aqui...
    if (any(lessThan(worldPos, u_worldBoundsMin)) || any(greaterThanEqual(worldPos, u_worldBoundsMax))) {
       return data;
    }

    // Se a posição estiver dentro do mesmo node da intersecção anterior, continua da busca dele
    // senão volta a busca da raiz da octree
    bool isInside = all(greaterThanEqual(worldPos, minBound)) && 
                    all(lessThan(worldPos, maxBound));
    
    int mask = int(isInside);       // 1 se dentro, 0 se fora
    int invMask = 1 - mask;         // 0 se dentro, 1 se fora

    data.nodeCoord = currentNodeCoord * mask; // (x * 1) ou (x * 0)
    data.nodeMin = (minBound * mask) + (u_worldBoundsMin * invMask);
    data.nodeMax = (maxBound * mask) + (u_worldBoundsMax * invMask);
    
    for (int i = 0; i < 16; i++) {
        // LEITURA DIRETA DE INTEIROS
        uvec4 nodeData = getNodeData(data.nodeCoord); 

        // Comparação direta de inteiros (>= 255u)
        if (nodeData.a >= LEAF_FLAG) {            
            int linearIndex = toLinear(data.nodeCoord);
            
            // Lê coordenadas
            ivec3 coordTexelCoord = fromLinear(linearIndex + 1);
            uvec4 coordData = getNodeData(coordTexelCoord);

            // Coordenada salva já é inteiro. Apenas cast para ivec3.
            ivec3 storedCoord = ivec3(coordData.rgb);

            // Lê Propriedades
            ivec3 propTexelCoord = fromLinear(linearIndex + 2);
            uvec4 propData = getNodeData(propTexelCoord);

            if (all(equal(storedCoord, worldPos)) && propData.a == 255u) {
                // Precisamos converter a cor de volta para float (0.0-1.0) para o raymarcher
                data.color.rgb = vec3(nodeData.rgb) / 255.0;
                data.color.a = float(coordData.a) / 255.0;
                
                // decodeProperties original esperava vec4 float. Adaptamos:
                vec4 propDataFloat = vec4(propData) / 255.0;
                data.properties = decodeProperties(propDataFloat);

                return data;
            }
            return data;
        }

        // Nó Interno
        if (nodeData.a <= INTERNAL_NODE_FLAG) {
            // Pega ponteiro direto (sem conversão de cor)
            ivec3 pointerBlockBaseCoord = decodePointer(nodeData.rgb);
            ivec3 midPoint = data.nodeMin + ((data.nodeMax - data.nodeMin) >> 1); // Divisão por 2 via shift é mais rápida
            int childIndices = getchildIndices(worldPos, midPoint);
            
            int linearBaseIndex = toLinear(pointerBlockBaseCoord);
            ivec3 childPointerCoord = fromLinear(linearBaseIndex + childIndices);
            
            uvec4 childPointerData = getNodeData(childPointerCoord);
            ivec3 nextNode = decodePointer(childPointerData.rgb);

            if (all(equal(nextNode, ivec3(0)))) {
                data.color = vec4(0.0); // Mark as empty
                return data;
            }

            // Guarda as informações do nó pai
            currentNodeCoord = data.nodeCoord;
            minBound = data.nodeMin;
            maxBound = data.nodeMax;

            data.nodeCoord = nextNode;
            getChildBounds(childIndices, data.nodeMin, data.nodeMax);
            continue;
        }
        return data;
    }
    return data;
}

// --- Raymarching ---

bool isInsideWorld(ivec3 c) {
    return all(greaterThanEqual(c, u_worldBoundsMin)) && all(lessThan(c, u_worldBoundsMax));
}

bool addRay(inout Ray rays[MAX_RAYS], Ray ray, inout int stackSize) {
    if (!ray.defined || stackSize >= MAX_RAYS) return false;
    rays[stackSize++] = ray;
    return true;
}


vec4 accumulateColors(Ray rays[MAX_RAYS], int rayCount) {
    vec3 result = vec3(0.0);
    float totalWeight = 0.0;
    
    // OTIMIZADO: Loop unrolling manual para MAX_RAYS=8
    for(int i = 0; i < rayCount; ++i){
        if (rays[i].defined){
            result += rays[i].colorTint.rgb * rays[i].weight;
        }
    }

    return vec4(result, 1.0);
}

bool hitMarching(vec3 rayOrigin, vec3 rayDir, float rayIOF, out ivec3 hitMapPos, out vec3 hitPoint, out vec3 hitNormal, out VoxelData prevVoxel, out VoxelData hitVoxel) {
    
    vec3 rayPos = rayOrigin;
    float invLen = inversesqrt(dot(rayDir, rayDir));
    rayDir *= invLen;

    // Epsilon pequeno para cruzar a fronteira
    const float DIR_EPSILON = 1e-8;
    const float EPS = 0.0001;
    
    // Evita divisão por zero
    vec3 invDir;
    invDir.x = (abs(rayDir.x) < DIR_EPSILON) ? 1e20 : 1.0 / rayDir.x;
    invDir.y = (abs(rayDir.y) < DIR_EPSILON) ? 1e20 : 1.0 / rayDir.y;
    invDir.z = (abs(rayDir.z) < DIR_EPSILON) ? 1e20 : 1.0 / rayDir.z;


    // Começa a procurar o voxel da root
    ivec3 currentNodeCoord = ivec3(0);
    ivec3 nodeMin = u_worldBoundsMin;
    ivec3 nodeMax = u_worldBoundsMax;
    // Pega o estado inicial
    ivec3 mapPos = ivec3(floor(rayPos));
    hitVoxel = octreeFind(mapPos, nodeMin, nodeMax, currentNodeCoord);
    
    // Inicializa prevVoxel na primeira iteração
    prevVoxel = hitVoxel;
    
    // Define um limite de segurança para o loop
    for (int i = 0; i < 1024; ++i) {
        vec3 boxMin = vec3(hitVoxel.nodeMin);
        vec3 boxMax = vec3(hitVoxel.nodeMax);

        float voxelSize = max(1.0, (boxMax.x - boxMin.x) * 0.125);
        vec3 tMax = (step(0.0, rayDir) - fract((rayPos - boxMin) / voxelSize)) * invDir * voxelSize;
        
        // 3. Descubra qual face atingimos primeiro (o menor t)
        // Isso nos dá a NORMAL e a distância do passo.
        float tStep = min(tMax.x, min(tMax.y, tMax.z));
        int axis = (tMax.x < tMax.y) ? ((tMax.x < tMax.z) ? 0 : 2) : ((tMax.y < tMax.z) ? 1 : 2);
        hitNormal = vec3(0.0);
        hitNormal[axis] = -sign(rayDir[axis]);
        
        // Avança o raio para EXATAMENTE a borda
        // Nota: O 'tStep' é a distância geométrica exata até a parede.
        rayPos += rayDir * tStep;

        vec3 stepDir = sign(rayDir);

        // Se o raio for perfeitamente alinhado, a matemática acima é segura.
        // Mas para garantir que cruzamos a face no eixo correto:
        rayPos[axis] += stepDir[axis] * EPS;

        // Recalcula mapPos baseado no ponto levemente penetrado
        mapPos = ivec3(floor(rayPos));
        
        // Verifica se saiu do mundo
        if (!isInsideWorld(mapPos)) return false;

        // Salva o estado anterior antes de atualizar
        prevVoxel = hitVoxel;
        // Busca o NOVO voxel na nova posição
        hitVoxel = octreeFind(mapPos, nodeMin, nodeMax, currentNodeCoord);
        
        // 5. Verifica mudança de meio (lógica de Hit)
        float prevRefrac = (prevVoxel.color.a > 0.0 && prevVoxel.properties[0] > 0.0) ? prevVoxel.properties[0] : rayIOF;
        float currentRefrac = (hitVoxel.color.a > 0.0 && hitVoxel.properties[0] > 0.0) ? hitVoxel.properties[0] : 1.0;

        if (abs(currentRefrac - prevRefrac) > EPS) {
            hitMapPos = mapPos;
            // O ponto de hit exato é a posição atual (que está na borda)
            hitPoint = rayPos;
            return true;
        }
    }
    
    return false;
}

// Simplified raymarch just for occlusion
bool inShadow(vec3 origin, vec3 lightDir) {
    vec3 rayPos = origin;

    const float DIR_EPSILON = 1e-8;
    const float EPS = 0.001;

    vec3 invDir;
    invDir.x = (abs(lightDir.x) < DIR_EPSILON) ? 1e20 : 1.0 / lightDir.x;
    invDir.y = (abs(lightDir.y) < DIR_EPSILON) ? 1e20 : 1.0 / lightDir.y;
    invDir.z = (abs(lightDir.z) < DIR_EPSILON) ? 1e20 : 1.0 / lightDir.z;

    ivec3 mapPos = ivec3(floor(rayPos));
    VoxelData vox;

    // Começa a procurar o voxel da root
    ivec3 currentNodeCoord = ivec3(0);
    ivec3 nodeMin = u_worldBoundsMin;
    ivec3 nodeMax = u_worldBoundsMax;

    for (int i = 0; i < 64; ++i) {
        vox = octreeFind(mapPos, nodeMin, nodeMax, currentNodeCoord);
        
        if (vox.color.a > 0.1) return true;

        vec3 boxMin = vec3(vox.nodeMin);
        vec3 boxMax = vec3(vox.nodeMax);

        float voxelSize = max(1.0, (boxMax.x - boxMin.x) * 0.125);
        vec3 tMax = (step(0.0, lightDir) - fract((rayPos - boxMin) / voxelSize)) * invDir * voxelSize;
        float tStep = min(tMax.x, min(tMax.y, tMax.z));
        int axis = (tMax.x < tMax.y) ? ((tMax.x < tMax.z) ? 0 : 2) : ((tMax.y < tMax.z) ? 1 : 2);
        
        rayPos += lightDir * tStep;
        rayPos[axis] += sign(lightDir[axis]) * EPS;
        mapPos = ivec3(floor(rayPos));

        if (!isInsideWorld(mapPos)) return false;
    }
    return false;
}

float getVoxelEdgeAO(vec3 hitPoint, vec3 normal) {
    // Transforma o ponto de hit para espaço local do voxel (0.0 a 1.0)
    // Assumindo que u_voxelScale já foi aplicado no hitPoint antes de chamar ou ajustando aqui
    vec3 voxelLocal = fract(hitPoint * u_voxelScale);
    
    // Descobre em qual plano (UV) estamos baseados na normal
    vec2 uv;
    if (abs(normal.x) > 0.5) uv = voxelLocal.yz;
    else if (abs(normal.y) > 0.5) uv = voxelLocal.xz;
    else uv = voxelLocal.xy;

    // Calcula a distância para a borda mais próxima (0.0 = borda, 0.5 = centro)
    vec2 edgeDist = min(uv, 1.0 - uv);
    float dist = min(edgeDist.x, edgeDist.y);

    // Cria um gradiente suave: escuro na borda, claro no centro
    // Ajuste 0.05 para bordas mais grossas ou finas
    return smoothstep(0.0, 0.1, dist);
}

vec4 raymarching_fromDir(vec3 rayOrigin, vec3 rayDir) {
    ivec3 currentNodeCoord = ivec3(0);
    ivec3 nodeMin = u_worldBoundsMin;
    ivec3 nodeMax = u_worldBoundsMax;

    vec3 gridRayOrigin = rayOrigin * u_voxelScale;

    ivec3 thisMapPos = ivec3(floor(gridRayOrigin));
    VoxelData thisVoxel = octreeFind(thisMapPos, nodeMin, nodeMax, currentNodeCoord);

    float startIOF = (thisVoxel.properties[0] > 0.0 && thisVoxel.properties[0] < 3.0) 
                      ? thisVoxel.properties[0] : 1.0;

    Ray rayStack[MAX_RAYS];
    Ray resultRays[MAX_RAYS];
    for (int i = 0; i < MAX_RAYS; ++i) {
        rayStack[i].defined = false;
        resultRays[i].defined = false;
        resultRays[i].weight = 0.0;
        resultRays[i].colorTint = vec4(0.0);
    }

    float invLen = inversesqrt(dot(rayDir, rayDir));
    rayDir = rayDir * invLen;
    rayStack[0] = Ray(
        gridRayOrigin, rayDir, startIOF, 1.0, true, globalLight, 0.0,
        thisVoxel.color.a > 0.0 ? thisVoxel.color : vec4(1.0),
        thisVoxel.color.a * 5.0
    );
    int stackSize = 1;
    int resultSize = 0;

    while (stackSize > 0) {
        Ray currentRay = rayStack[--stackSize];
        rayStack[stackSize].defined = false;
        
        if (!currentRay.defined) continue;

        ivec3 mapPos;
        vec3 hitPoint, hitNormal;
        VoxelData lastVoxel, hitVoxel;
        
        bool hit = hitMarching(currentRay.origin, currentRay.direction, currentRay.IOF,
                              mapPos, hitPoint, hitNormal, lastVoxel, hitVoxel);

        if (!hit) {
            // Apply Beer's Law and add to results
            vec4 transmittedColor = currentRay.colorTint;
            if (currentRay.distanceInMedium > 1e-6 && currentRay.mediumDensity > 0.0) {
                vec3 absorption = exp(-currentRay.mediumDensity * currentRay.distanceInMedium * 
                                      (vec3(1.0) - currentRay.mediumColor.rgb));
                transmittedColor.rgb *= absorption;
            }
            
            if (resultSize < MAX_RAYS) {
                resultRays[resultSize++] = Ray(
                    vec3(0.0), vec3(0.0), 0.0, currentRay.weight, true,
                    transmittedColor * skyColor, 0.0, vec4(0.0), 0.0
                );
            }
            continue;
        }

        vec3 normal = length(hitNormal) > 0.0 ? hitNormal : vec3(0.0, 1.0, 0.0);

        vec3 hitPointWorld = hitPoint / u_voxelScale;
        // Adiciona metade do tamanho na direção da normal para chegar ao centro da FACE
        vec3 faceCenterGrid = vec3(mapPos) + normal;

        // Update distance traveled through current medium
        currentRay.distanceInMedium += length(faceCenterGrid - currentRay.origin) / u_voxelScale;
        
        if (hitVoxel.color.a <= 0.0) hitVoxel.properties = vec3(1.0, 0.0, 0.0);
        if (lastVoxel.color.a <= 0.0) lastVoxel.properties = currentRay.IOF > 0.0 ? vec3(0.0) : vec3(1.0, 0.0, 0.0);

        vec3 finalLight = vec3(max(dot(normal, lightDir), 0.0));
        
        // Determine surface color based on which side we're hitting
        vec4 surfaceColor = hitVoxel.color.a > 0.0 ? hitVoxel.color : lastVoxel.color;
        float n2 = hitVoxel.properties[0] > 0.0 ? hitVoxel.properties[0] : 1.0;
        float n1 = lastVoxel.properties[0] > 0.0 ? lastVoxel.properties[0] : 1.0;

        vec3 incidentDir = currentRay.direction;

        // Apply Beer's Law
        vec4 transmittedColor = currentRay.colorTint;
        if (currentRay.distanceInMedium > 1e-6 && currentRay.mediumDensity > 0.0) {
            vec3 absorption = exp(-currentRay.mediumDensity * currentRay.distanceInMedium * 
                                  (vec3(1.0) - currentRay.mediumColor.rgb));
            transmittedColor.rgb *= absorption;
        }

        // === TRANSPARENT/TRANSLUCENT SURFACES ===
        if (surfaceColor.a < 1) {
            float cosi = dot(incidentDir, normal);
            
            if (cosi > 0.0) {
                normal = -normal;
                float tmp = n1; n1 = n2; n2 = tmp;
            }

            vec3 refractDir = refract(incidentDir, normal, n1 / n2);

            float R0 = (n1 - n2) / (n1 + n2) * (n1 - n2) / (n1 + n2);
            float cosTheta = max(0.0, dot(-incidentDir, normal));
            float fresnel = clamp(R0 + (1.0 - R0) * pow(1.0 - cosTheta, 5.0), 0.0, 1.0);

            bool hasTIR = length(refractDir) < 0.001;
            float reflectIntensity = fresnel;
            float refractIntensity = hasTIR ? 0.0 : (1.0 - fresnel);

            // DONT WASTE ENERGY YOU SICK FUCK
            if(stackSize == MAX_RAYS || reflectIntensity <= 0.001 || refractIntensity <= 0.001){
                vec4 litSurfaceColor = vec4(surfaceColor.rgb * finalLight, 1.0);
                Ray finalRay;
                finalRay.defined = true;
                finalRay.weight = currentRay.weight;
                finalRay.colorTint = transmittedColor * litSurfaceColor;
                
                addRay(resultRays, finalRay, resultSize);
                continue;
            }

            // ---- Reflection ray ----
            if (reflectIntensity > 0.001 && stackSize < MAX_RAYS) {
                float reflectWeight = currentRay.weight * reflectIntensity;
                if (reflectWeight > 1e-4)
                    rayStack[stackSize++] = Ray(
                        hitPoint + normal * 1e-4, reflect(incidentDir, normal), n1,
                        reflectWeight, true,
                        transmittedColor, 0.0, lastVoxel.color, lastVoxel.color.a * 5.0
                    );
            }

            // ---- Refraction ray ----
            if (refractIntensity > 0.001 && stackSize < MAX_RAYS && !hasTIR) {
                rayStack[stackSize++] = Ray(
                    hitPoint - normal * 1e-4, refractDir, n2,
                    currentRay.weight * refractIntensity, true,
                    transmittedColor, 0.0, hitVoxel.color, hitVoxel.color.a * 5.0
                );
            }
        }
        else {
            // === SUPERFÍCIE OPACA ESTILIZADA ===
            
            // 1. Calcula o "Fake AO" das bordas do cubo
            float edgeAO = getVoxelEdgeAO(hitPointWorld, normal); // Use coordenada de mundo real aqui
            edgeAO = mix(0.6, 1.0, edgeAO); // Nunca escurece totalmente (mínimo 0.6)

            // 2. Iluminação Direta (Sol)
            float ndotl = max(dot(normal, lightDir), 0.0);
            ndotl = floor(ndotl * 4.0) / 4.0;
            
            // Sombras: Verifica se está na sombra
            bool isInShadow = false;
            if (ndotl > 0.0) {
                isInShadow = inShadow(faceCenterGrid + normal * 1e-3, lightDir);
            }
            
            float shadowFactor = isInShadow ? 0.0 : 1.0;

            // 3. Iluminação Ambiente (Hemisférica)
            // Luz vem de cima (Céu azulado) e reflete de baixo (Chão esverdeado/marrom)
            float upFactor = normal.y * 0.5 + 0.5; // Mapeia -1..1 para 0..1
            vec3 ambientLight = mix(vec3(0.1, 0.15, 0.2), vec3(0.6, 0.7, 0.9), upFactor); 
            
            // 4. Composição da Luz Final
            // A luz direta é somada à ambiente. A sombra afeta APENAS a direta.
            vec3 directLight = globalLight.rgb * ndotl * shadowFactor;
            
            vec3 finalIrradiance = (directLight + ambientLight) * edgeAO;

            vec4 litSurfaceColor = vec4(surfaceColor.rgb * finalIrradiance, 1.0);

            // --- Specular (Mantém o seu, mas estilizado) ---
            // Voxels geralmente ficam bonitos com especular pequeno e forte
            float specularFactor = hitVoxel.properties[2];
            if (specularFactor > 0.01) {
                 vec3 reflectDir = reflect(incidentDir, normal);
                 float spec = pow(max(dot(reflectDir, incidentDir), 0.0), 32.0); // Shininess alto
                 
                 // Adiciona o brilho especular na cor (se não estiver na sombra)
                 if (!isInShadow) {
                    litSurfaceColor.rgb += vec3(spec * specularFactor);
                 }

                 // Se for muito reflexivo (espelho/metal), lança o raio
                 float reflectWeight = currentRay.weight * specularFactor;
                 if (reflectWeight > 1e-4 && stackSize < MAX_RAYS) {
                    rayStack[stackSize++] = Ray(
                        hitPoint + normal * 1e-4, reflectDir, n1,
                        reflectWeight, true,
                        transmittedColor, 0.0, vec4(1.0), 0.0
                    );
                 }
            }
            
            // Diffuse (O que sobrou do specular é difuso)
            float diffuseWeight = (1.0 - specularFactor);
            if (diffuseWeight > 0.01 && resultSize < MAX_RAYS) {
                 Ray finalRay;
                 finalRay.defined = true;
                 finalRay.weight = currentRay.weight * diffuseWeight;
                 
                 // A mágica acontece aqui: Multiplicamos a cor do voxel pela luz calculada
                 finalRay.colorTint = transmittedColor * litSurfaceColor;
                 
                 addRay(resultRays, finalRay, resultSize);
            }
        }
    }
    
    return accumulateColors(resultRays,resultSize);
}

void main() {
    ivec2 pixel_coords = ivec2(gl_GlobalInvocationID.xy);
    ivec2 dims = imageSize(destTex);

    if (pixel_coords.x < 0 || pixel_coords.x >= dims.x || pixel_coords.y < 0 || pixel_coords.y >= dims.y) return;

    float u = (float(pixel_coords.x) / float(dims.x)) * 2.0 - 1.0;
    float v = (float(pixel_coords.y) / float(dims.y)) * 2.0 - 1.0;

    vec4 clip = vec4(u, v, -1.0, 1.0);
    vec4 view = invProjection * clip;
    if (abs(view.w) > 1e-6) view /= view.w;
    vec3 viewDir = normalize(view.xyz);
    vec3 worldDir = normalize((invView * vec4(viewDir, 0.0)).xyz);

    vec4 finalColor = raymarching_fromDir(cameraPos.xyz, worldDir);

    if (length(finalColor.rgb) == 0.0) finalColor = skyColor;

    imageStore(destTex, pixel_coords, finalColor);
}