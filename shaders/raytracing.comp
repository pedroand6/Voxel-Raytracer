#version 450 core

// A dimensão da sua folha em texels (baseado no seu C++)
#define LEAF_SIZE 2

const int MAX_RAYS = 8;
const int INDIRECT_SAMPLES = 1;
const int BOUNCES = 1;
const float PI = 3.14159265359;

const vec4 skyColor = vec4(0.5, 0.7, 1.0, 1.0);
const float sunIntensity = 3.0;

layout (local_size_x = 8, local_size_y = 8, local_size_z = 1) in;
layout (rgba8, binding = 0) uniform writeonly image2D destTex;

layout (std140, binding = 1) uniform Camera {
    mat4 invProjection;
    mat4 invView;
    vec4 cameraPos;
};

layout (binding = 2) uniform usampler3D u_octreeTexture;
layout (rg32i, binding = 3) uniform writeonly iimage2D voxelIDTex;

// A dimensão da sua textura (ex: 256.0 para uma textura 256x256x256)
uniform int u_texDim;

uniform float u_voxelScale; // A escala do voxel no mundo, ex: 2.0 significa 1 voxel a cada 0.5 unidades de espaço

// Os cantos min/max do volume total da sua octree no espaço do mundo
uniform ivec3 u_worldBoundsMin;
uniform ivec3 u_worldBoundsMax;
ivec3 worldSize = u_worldBoundsMax - u_worldBoundsMin;

uniform vec4 globalLight;
uniform vec3 lightDir;

uniform ivec3 u_highlightedVoxel;

/*
 * Estrutura de Retorno
 * Contém os dados do voxel que encontramos.
 */
struct VoxelData {
    lowp vec4 color;       // Cor (RGBA)
    lowp vec3 properties;  // Refração, Iluminação, K
    mediump ivec3 nodeMin;
    mediump ivec3 nodeMax;
    mediump ivec3 nodeCoord;
};

/*
 * Estrutura de Raio
 * Usada para rastreamento de raios.
 */
struct Ray {
    mediump vec3 origin;
    mediump vec3 direction;
    mediump float IOF;
    mediump float weight;
    bool defined;
    lowp vec4 colorTint;
    mediump float distanceInMedium;
    lowp vec4 mediumColor;
    lowp float mediumDensity;
    int depth;
};

/*
 * Funções Auxiliares
 */

// Converte uma coordenada 3D em um índice linear 1D
int toLinear(ivec3 coord) {
    return coord.x + u_texDim * (coord.y + u_texDim * coord.z);
}

// Converte um índice linear 1D de volta para uma coordenada 3D
ivec3 fromLinear(int index) {
    int tex_dim_sq = u_texDim * u_texDim;
    int z = index / tex_dim_sq;
    int rem = index - z * tex_dim_sq;
    return ivec3(rem - (rem / u_texDim) * u_texDim, rem / u_texDim, z);
}

// Converte um "ponteiro" (cor RGB 0.0-1.0) de volta para 
// uma coordenada inteira de texel (ex: [0, 255])
uvec2 decodePointer(uvec3 pointer_rgb) {
    // Os valores já são os inteiros corretos (0-255)
    uint val = pointer_rgb.r | (pointer_rgb.g << 8) | (pointer_rgb.b << 16);
    uint isLeafBlock = (val & 0x800000u) != 0u ? 1u : 0u;
    uint address = val & 0x7FFFFFu; // Remove flag bit 23

    return uvec2(address, isLeafBlock);
}

// Determina em qual filho (0-7) o voxel do mundo está
int getchildIndices(ivec3 worldPos, ivec3 nodeMidPoint) {
    // O ponto médio calculado por divisão de inteiros é o INÍCIO do bloco da direita.
    bvec3 greater = greaterThanEqual(worldPos, nodeMidPoint);
    return int(greater.x) * 4 + int(greater.y) * 2 + int(greater.z);
}

void getChildBounds(int childIndices, inout ivec3 nodeMin, inout ivec3 nodeMax) {
    ivec3 mid = nodeMin + (nodeMax - nodeMin) / 2; // half split

    // Se o bit estiver set => este child é o "lado alto" => min = mid, max = old max
    // Caso contrário => este child é o "lado baixo" => min = old min, max = mid
    nodeMin.x = ((childIndices & 4) != 0) ? mid.x : nodeMin.x;
    nodeMax.x = ((childIndices & 4) != 0) ? nodeMax.x : mid.x;

    nodeMin.y = ((childIndices & 2) != 0) ? mid.y : nodeMin.y;
    nodeMax.y = ((childIndices & 2) != 0) ? nodeMax.y : mid.y;

    nodeMin.z = ((childIndices & 1) != 0) ? mid.z : nodeMin.z;
    nodeMax.z = ((childIndices & 1) != 0) ? nodeMax.z : mid.z;
}

bool hasChild(uint mask, int childIdx) {
    return ((mask >> childIdx) & 1u) != 0u;
}

// Converte os dados de propriedade (armazenados como 0-255) de volta
// para os valores float originais.
vec3 decodeProperties(vec4 texel) {
    return vec3(texel.r * 3.0, texel.g, texel.b);
}

// Obtém o texel de dados de um nó. 
// texelFetch usa coordenadas inteiras (ivec3).
uvec4 getNodeData(ivec3 coord) {
    // texelFetch em usampler3D retorna uvec4 com os valores exatos (0-255)
    return texelFetch(u_octreeTexture, coord, 0);
}

VoxelData octreeFind(ivec3 worldPos, inout ivec3 minBound, inout ivec3 maxBound, inout ivec3 currentNodeCoord) {
    VoxelData data;
    data.color = vec4(0.0);
    data.properties = vec3(0.0);

    // Mantenha suas verificações de borda (u_worldBoundsMin/Max) aqui...
    if (any(lessThan(worldPos, u_worldBoundsMin)) || any(greaterThanEqual(worldPos, u_worldBoundsMax))) {
       return data;
    }

    // Se a posição estiver dentro do mesmo node da intersecção anterior, continua da busca dele
    // senão volta a busca da raiz da octree
    bool isInside = all(greaterThanEqual(worldPos, minBound)) && 
                    all(lessThan(worldPos, maxBound));
    
    int mask = int(isInside);       // 1 se dentro, 0 se fora
    int invMask = 1 - mask;         // 0 se dentro, 1 se fora

    data.nodeCoord = currentNodeCoord * mask; // (x * 1) ou (x * 0)
    data.nodeMin = (minBound * mask) + (u_worldBoundsMin * invMask);
    data.nodeMax = (maxBound * mask) + (u_worldBoundsMax * invMask);

    bool isLeaf = false;
    
    for (int i = 0; i < 16; i++) {
        // LEITURA DIRETA DE INTEIROS
        uvec4 nodeData = getNodeData(data.nodeCoord);

        // Comparação direta de inteiros (>= 255u)
        if (isLeaf) {            
            int linearIndex = toLinear(data.nodeCoord);

            // Lê Propriedades
            ivec3 propTexelCoord = fromLinear(linearIndex + 1);
            uvec4 propData = getNodeData(propTexelCoord);

            data.color.rgb = vec3(nodeData.rgb) / 255.0;
            data.color.a = float(propData.a) / 255.0;
            
            // decodeProperties original esperava vec4 float. Adaptamos:
            vec4 propDataFloat = vec4(propData) / 255.0;
            data.properties = decodeProperties(propDataFloat);
            return data;
        }
        else { // Nó interno
            // Pega ponteiro direto (sem conversão de cor)
            uvec2 pointerBlockBaseCoord = decodePointer(nodeData.rgb);
            ivec3 midPoint = data.nodeMin + ((data.nodeMax - data.nodeMin) / 2);
            int childIndices = getchildIndices(worldPos, midPoint);

            uint bitmask = uint(nodeData.a);

            // Verifica existência do filho
            bool childExists = hasChild(bitmask, childIndices);

            // Calcula endereço do filho
            uint beforeMask = bitmask & ((1u << uint(childIndices)) - 1u);
            uint offset = bitCount(beforeMask);
            
            ivec3 childPointerCoord = fromLinear(int(pointerBlockBaseCoord.x + offset));
            
            uvec4 childPointerData = getNodeData(childPointerCoord);
            uvec2 nextNode = decodePointer(childPointerData.rgb);
            isLeaf = (nextNode.y == 1u) ? true : false;

            // Guarda as informações do nó pai
            currentNodeCoord = data.nodeCoord;
            minBound = data.nodeMin;
            maxBound = data.nodeMax;

            data.nodeCoord = fromLinear(int(nextNode.x));
            getChildBounds(childIndices, data.nodeMin, data.nodeMax);

            if (!childExists) {
                data.color = vec4(0.0); // Mark as empty
                return data;
            }
            
            continue;
        }
        return data;
    }
    return data;
}

// --- Raymarching ---

bool isInsideWorld(ivec3 c) {
    return all(greaterThanEqual(c, u_worldBoundsMin)) && all(lessThan(c, u_worldBoundsMax));
}

bool addRay(inout Ray rays[MAX_RAYS], Ray ray, inout int stackSize) {
    if (!ray.defined || stackSize >= MAX_RAYS) return false;
    rays[stackSize++] = ray;
    return true;
}


vec4 accumulateColors(Ray rays[MAX_RAYS], int rayCount) {
    vec3 result = vec3(0.0);
    float totalWeight = 0.0;
    
    for(int i = 0; i < rayCount; ++i){
        if (rays[i].defined){
            result += rays[i].colorTint.rgb * rays[i].weight;
        }
    }

    return vec4(result, 1.0);
}

bool hitMarching(vec3 rayOrigin, vec3 rayDir, float rayIOF, out ivec3 hitMapPos, out vec3 hitPoint, out vec3 hitNormal, out VoxelData prevVoxel, out VoxelData hitVoxel) {
    
    vec3 rayPos = rayOrigin;
    float invLen = inversesqrt(dot(rayDir, rayDir));
    rayDir *= invLen;

    // Epsilon pequeno para cruzar a fronteira
    const float DIR_EPSILON = 1e-8;
    const float EPS = 0.0001;
    
    // Evita divisão por zero
    vec3 invDir;
    invDir.x = (abs(rayDir.x) < DIR_EPSILON) ? 1e20 : 1.0 / rayDir.x;
    invDir.y = (abs(rayDir.y) < DIR_EPSILON) ? 1e20 : 1.0 / rayDir.y;
    invDir.z = (abs(rayDir.z) < DIR_EPSILON) ? 1e20 : 1.0 / rayDir.z;


    // Começa a procurar o voxel da root
    ivec3 currentNodeCoord = ivec3(0);
    ivec3 nodeMin = u_worldBoundsMin;
    ivec3 nodeMax = u_worldBoundsMax;
    // Pega o estado inicial
    ivec3 mapPos = ivec3(floor(rayPos));
    hitVoxel = octreeFind(mapPos, nodeMin, nodeMax, currentNodeCoord);
    
    // Inicializa prevVoxel na primeira iteração
    prevVoxel = hitVoxel;
    
    // Define um limite de segurança para o loop
    for (int i = 0; i < 1024; ++i) {
        vec3 boxMin = vec3(hitVoxel.nodeMin);
        vec3 boxMax = vec3(hitVoxel.nodeMax);

        vec3 tPlane;
        tPlane.x = (rayDir.x > 0.0 ? boxMax.x : boxMin.x) - rayPos.x;
        tPlane.y = (rayDir.y > 0.0 ? boxMax.y : boxMin.y) - rayPos.y;
        tPlane.z = (rayDir.z > 0.0 ? boxMax.z : boxMin.z) - rayPos.z;

        // Tempo/Distância até as paredes
        vec3 tMax = tPlane * invDir;
        
        // 3. Descubra qual face atingimos primeiro (o menor t)
        // Isso nos dá a NORMAL e a distância do passo.
        float tStep = min(tMax.x, min(tMax.y, tMax.z));
        int axis = (tMax.x < tMax.y) ? ((tMax.x < tMax.z) ? 0 : 2) : ((tMax.y < tMax.z) ? 1 : 2);
        hitNormal = vec3(0.0);
        hitNormal[axis] = -sign(rayDir[axis]);
        
        // Avança o raio para EXATAMENTE a borda
        // Nota: O 'tStep' é a distância geométrica exata até a parede.
        rayPos += rayDir * tStep;

        vec3 stepDir = sign(rayDir);

        // Se o raio for perfeitamente alinhado, a matemática acima é segura.
        // Mas para garantir que cruzamos a face no eixo correto:
        rayPos[axis] += stepDir[axis] * EPS;

        // Recalcula mapPos baseado no ponto levemente penetrado
        mapPos = ivec3(floor(rayPos));
        
        // Verifica se saiu do mundo
        if (!isInsideWorld(mapPos)) return false;

        // Salva o estado anterior antes de atualizar
        prevVoxel = hitVoxel;
        // Busca o NOVO voxel na nova posição
        hitVoxel = octreeFind(mapPos, nodeMin, nodeMax, currentNodeCoord);
        
        // 5. Verifica mudança de meio (lógica de Hit)
        float prevRefrac = (prevVoxel.color.a > 0.0 && prevVoxel.properties[0] > 0.0) ? prevVoxel.properties[0] : rayIOF;
        float currentRefrac = (hitVoxel.color.a > 0.0 && hitVoxel.properties[0] > 0.0) ? hitVoxel.properties[0] : 1.0;

        if (abs(currentRefrac - prevRefrac) > EPS) {
            hitMapPos = mapPos;
            // O ponto de hit exato é a posição atual (que está na borda)
            hitPoint = rayPos;
            return true;
        }
    }
    
    return false;
}

// Simplified raymarch just for occlusion
int notInShadow(vec3 origin, vec3 lightDir) {
    vec3 rayPos = origin;

    const float DIR_EPSILON = 1e-8;
    const float EPS = 0.001;

    vec3 invDir;
    invDir.x = (abs(lightDir.x) < DIR_EPSILON) ? 1e20 : 1.0 / lightDir.x;
    invDir.y = (abs(lightDir.y) < DIR_EPSILON) ? 1e20 : 1.0 / lightDir.y;
    invDir.z = (abs(lightDir.z) < DIR_EPSILON) ? 1e20 : 1.0 / lightDir.z;

    ivec3 mapPos = ivec3(floor(rayPos));
    VoxelData vox;

    // Começa a procurar o voxel da root
    ivec3 currentNodeCoord = ivec3(0);
    ivec3 nodeMin = u_worldBoundsMin;
    ivec3 nodeMax = u_worldBoundsMax;

    for (int i = 0; i < 64; ++i) {
        vox = octreeFind(mapPos, nodeMin, nodeMax, currentNodeCoord);
        
        if (vox.color.a > 0.1 && vox.properties[1] == 0) return 0;

        vec3 boxMin = vec3(vox.nodeMin);
        vec3 boxMax = vec3(vox.nodeMax);

        vec3 tPlane;
        tPlane.x = (lightDir.x > 0.0 ? boxMax.x : boxMin.x) - rayPos.x;
        tPlane.y = (lightDir.y > 0.0 ? boxMax.y : boxMin.y) - rayPos.y;
        tPlane.z = (lightDir.z > 0.0 ? boxMax.z : boxMin.z) - rayPos.z;

        // Tempo/Distância até as paredes
        vec3 tMax = tPlane * invDir;
        float tStep = min(tMax.x, min(tMax.y, tMax.z));
        int axis = (tMax.x < tMax.y) ? ((tMax.x < tMax.z) ? 0 : 2) : ((tMax.y < tMax.z) ? 1 : 2);
        
        rayPos += lightDir * tStep;
        rayPos[axis] += sign(lightDir[axis]) * EPS;
        mapPos = ivec3(floor(rayPos));

        if (!isInsideWorld(mapPos)) return 1;
    }
    return 1;
}

uint rngState;

void initRNG(ivec2 pixelCoord, int sampleIndex) {
    // Better seed mixing for stratified samples
    uint seed = uint(pixelCoord.x) + uint(pixelCoord.y) * 1920u 
                + 123456u + uint(sampleIndex) * 78901u;
    rngState = seed * 747796405u + 2891336453u;
    uint word = ((rngState >> ((rngState >> 28u) + 4u)) ^ rngState) * 277803737u;
    rngState = (word >> 22u) ^ word;
}

float rand() {
    rngState = rngState * 747796405u + 2891336453u;
    uint word = ((rngState >> ((rngState >> 28u) + 4u)) ^ rngState) * 277803737u;
    rngState = (word >> 22u) ^ word;
    return float(rngState) / 4294967296.0;
}

vec2 rand2() { 
    return vec2(rand(), rand()); 
}

// Função para obter uma direção aleatória num hemisfério de acordo com Monte Carlo
vec3 cosineSampleHemisphere(vec3 normal, vec2 r) {
    float phi = 2.0 * PI * r.y;
    float cosTheta = sqrt(r.x);
    float sinTheta = sqrt(1.0 - r.x);

    float x = sinTheta * cos(phi);
    float z = sinTheta * sin(phi);
    
    vec3 up = abs(normal.z) < 0.999 ? vec3(0, 0, 1) : vec3(1, 0, 0);
    vec3 tangent = normalize(cross(up, normal));
    vec3 bitangent = cross(normal, tangent);
    
    return normalize(tangent * x + 
                     bitangent * z + 
                     normal * cosTheta);
}

int getFaceIndex(vec3 normal) {
    // Evita problemas com normais (0,0,0) ou mal normalizadas
    if (length(normal) < 0.5) return 0;
    
    vec3 absNorm = abs(normal);
    
    // Testa qual eixo é o predominante (X, Y ou Z)
    if (absNorm.x > absNorm.y && absNorm.x > absNorm.z) {
        return normal.x > 0.0 ? 0 : 1; // +X ou -X
    } else if (absNorm.y > absNorm.z) {
        return normal.y > 0.0 ? 2 : 3; // +Y ou -Y
    } else {
        return normal.z > 0.0 ? 4 : 5; // +Z ou -Z
    }
}

vec4 pathTrace(vec3 rayOrigin, vec3 rayDir, inout int primaryVoxelID, inout int pixelDist) {
    ivec3 currentNodeCoord = ivec3(0);
    ivec3 nodeMin = u_worldBoundsMin;
    ivec3 nodeMax = u_worldBoundsMax;

    primaryVoxelID = 0;
    pixelDist = worldSize.x;

    vec3 gridRayOrigin = rayOrigin * u_voxelScale;

    ivec3 thisMapPos = ivec3(floor(gridRayOrigin));
    VoxelData thisVoxel = octreeFind(thisMapPos, nodeMin, nodeMax, currentNodeCoord);

    float startIOF = (thisVoxel.properties[0] > 0.0 && thisVoxel.properties[0] < 3.0) 
                      ? thisVoxel.properties[0] : 1.0;

    Ray rayStack[MAX_RAYS];
    for (int i = 0; i < MAX_RAYS; ++i) {
        rayStack[i].defined = false;
    }

    float invLen = inversesqrt(dot(rayDir, rayDir));
    rayDir = rayDir * invLen;
    rayStack[0] = Ray(
        gridRayOrigin, rayDir, startIOF, 1.0, true, globalLight, 0.0,
        thisVoxel.color.a > 0.0 ? thisVoxel.color : vec4(1.0),
        thisVoxel.color.a * 5.0, 0
    );
    int stackSize = 1;

    vec3 finalColor = vec3(0.0);

    while (stackSize > 0) {
        Ray currentRay = rayStack[--stackSize];
        rayStack[stackSize].defined = false;
        
        if (!currentRay.defined) continue;

        ivec3 mapPos;
        vec3 hitPoint, hitNormal;
        VoxelData lastVoxel, hitVoxel;
        
        bool hit = hitMarching(currentRay.origin, currentRay.direction, currentRay.IOF,
                              mapPos, hitPoint, hitNormal, lastVoxel, hitVoxel);

        vec4 transmittedColor = currentRay.colorTint;
        if (!hit && currentRay.depth <= 0) {
            if (currentRay.distanceInMedium > 1e-6 && currentRay.mediumDensity > 0.0) {
                vec3 absorption = exp(-currentRay.mediumDensity * currentRay.distanceInMedium * 
                                      (vec3(1.0) - currentRay.mediumColor.rgb));
                transmittedColor.rgb *= absorption;
            }

            // Add sky contribution scaled by global light
            finalColor += globalLight.rgb * skyColor.rgb * transmittedColor.rgb * currentRay.weight;
            continue;
        }
        else if(!hit){
            finalColor += transmittedColor.rgb * skyColor.rgb * sunIntensity * currentRay.weight / PI;
            continue;
        }

        vec3 normal = length(hitNormal) > 0.0 ? hitNormal : vec3(0.0, 1.0, 0.0);
        vec3 hitPointWorld = hitPoint / u_voxelScale;
        vec3 faceCenterGrid = vec3(mapPos) + normal;

        currentRay.distanceInMedium += length(hitPointWorld - currentRay.origin) / u_voxelScale;
        
        if (hitVoxel.color.a <= 0.0) hitVoxel.properties = vec3(1.0, 0.0, 0.0);
        if (lastVoxel.color.a <= 0.0) lastVoxel.properties = currentRay.IOF > 0.0 ? vec3(0.0) : vec3(1.0, 0.0, 0.0);

        vec4 surfaceColor = hitVoxel.color.a > 0.0 ? hitVoxel.color : lastVoxel.color;
        float n2 = hitVoxel.properties[0] > 0.0 ? hitVoxel.properties[0] : 1.0;
        float n1 = lastVoxel.properties[0] > 0.0 ? lastVoxel.properties[0] : 1.0;

        vec3 incidentDir = currentRay.direction;

        if (currentRay.distanceInMedium > 1e-6 && currentRay.mediumDensity > 0.0) {
            vec3 absorption = exp(-currentRay.mediumDensity * currentRay.distanceInMedium * 
                                  (vec3(1.0) - currentRay.mediumColor.rgb));
            transmittedColor.rgb *= absorption;
        }

        if(mapPos == u_highlightedVoxel){
            surfaceColor = vec4(vec3(1.0) - surfaceColor.rgb, 1.0);
        } 

        float cosi = dot(incidentDir, normal);
        if (cosi > 0.0) {
            normal = -normal;
            float tmp = n1; n1 = n2; n2 = tmp;
        }

        vec3 refractDir = refract(incidentDir, normal, n1 / n2);
        float R0 = (n1 - n2) / (n1 + n2) * (n1 - n2) / (n1 + n2);
        float cosTheta = max(0.0, dot(-incidentDir, normal));
        float fresnel = clamp(R0 + (1.0 - R0) * pow(1.0 - cosTheta, 5.0), 0.0, 1.0);

        bool hasTIR = length(refractDir) < 0.001;
        float reflectIntensity = fresnel;
        float refractIntensity = hasTIR ? 0.0 : (1.0 - fresnel);

        float ndotl = max(dot(normal, lightDir), 0.0); // Fator de iluminação direta

        if (currentRay.depth == 0 && primaryVoxelID == 0 && surfaceColor.a >= 1) {
            int voxelIndex = toLinear(mapPos);
            int faceIndex = getFaceIndex(hitNormal);
            primaryVoxelID = (voxelIndex * 6) + faceIndex;
            pixelDist = int(length(hitPointWorld - rayOrigin));
        }

        // === TRANSPARENT/TRANSLUCENT ===
        if (currentRay.depth <= 0 && surfaceColor.a < 1) {
            if(stackSize == MAX_RAYS || reflectIntensity <= 0.001 || refractIntensity <= 0.001){
                vec3 directLight = globalLight.rgb * ndotl;
                vec4 litSurfaceColor = vec4(surfaceColor.rgb * directLight, 1.0);
                finalColor += transmittedColor.rgb * litSurfaceColor.rgb * currentRay.weight;
                continue;
            }

            if (reflectIntensity > 0.001 && stackSize < MAX_RAYS) {
                float reflectWeight = currentRay.weight * reflectIntensity;
                if (reflectWeight > 1e-4)
                    rayStack[stackSize++] = Ray(
                        hitPoint + normal * 1e-4, reflect(incidentDir, normal), n1,
                        reflectWeight, true,
                        transmittedColor, currentRay.distanceInMedium, lastVoxel.color, lastVoxel.color.a * 5.0, currentRay.depth
                    );
            }

            if (refractIntensity > 0.001 && stackSize < MAX_RAYS && !hasTIR) {
                rayStack[stackSize++] = Ray(
                    hitPoint - normal * 1e-4, refractDir, n2,
                    currentRay.weight * refractIntensity, true,
                    transmittedColor, 0.0, hitVoxel.color, hitVoxel.color.a * 5.0, currentRay.depth
                );
            }
        }
        else {
            // 1. Calculate Emission (If the object glows, add it now)
            float emissionStrength = hitVoxel.properties[1] * 10.0;
            if (emissionStrength > 0.0 && currentRay.depth == 0) {
                finalColor += transmittedColor.rgb * surfaceColor.rgb * emissionStrength * currentRay.weight;
                continue;
            }else if(emissionStrength > 0.0){
                finalColor += transmittedColor.rgb * surfaceColor.rgb * emissionStrength * currentRay.weight / PI;
                continue;
            }

            // 2. Direct Lighting (Next Event Estimation) - Keep this if you separate direct/indirect
            if (currentRay.depth == 0) {
                // Calculate direct lighting normally
                vec3 directLight = globalLight.rgb * notInShadow(hitPoint + normal * 2e-3, lightDir) * ndotl;
                finalColor += directLight * surfaceColor.rgb * transmittedColor.rgb * currentRay.weight / PI;
            }
            else{
                float ambientCoefficient = max(1.0 - exp(-currentRay.distanceInMedium / 512.0), 0.01);
                finalColor += ambientCoefficient * surfaceColor.rgb * transmittedColor.rgb * currentRay.weight / PI;
                continue;
            }

            // 3. Indirect Lighting (Bounces)
            for(int i = 0; i < INDIRECT_SAMPLES && stackSize < MAX_RAYS && currentRay.depth <= BOUNCES; ++i){
                vec2 r = rand2();
                vec3 bounceDir = cosineSampleHemisphere(normal, r);
                
                // We divide by INDIRECT_SAMPLES to average the Monte Carlo split
                float newWeight = currentRay.weight / float(INDIRECT_SAMPLES);

                rayStack[stackSize++] = Ray(
                    hitPoint + normal * 1e-1, 
                    bounceDir,
                    n1,
                    newWeight, // The new corrected throughput
                    true,
                    transmittedColor * surfaceColor, 
                    0.0, 
                    lastVoxel.color,
                    lastVoxel.color.a * 5.0, 
                    currentRay.depth + 1
                );
            }
            
        }
    }
    
    return vec4(finalColor, 1.0);
}

void main() {
    ivec2 pixel_coords = ivec2(gl_GlobalInvocationID.xy);
    ivec2 dims = imageSize(destTex);

    if (pixel_coords.x < 0 || pixel_coords.x >= dims.x || pixel_coords.y < 0 || pixel_coords.y >= dims.y) return;
    initRNG(pixel_coords, 0);

    float u = (float(pixel_coords.x) / float(dims.x)) * 2.0 - 1.0;
    float v = (float(pixel_coords.y) / float(dims.y)) * 2.0 - 1.0;

    vec4 clip = vec4(u, v, -1.0, 1.0);
    vec4 view = invProjection * clip;
    if (abs(view.w) > 1e-6) view /= view.w;
    vec3 viewDir = normalize(view.xyz);
    vec3 worldDir = normalize((invView * vec4(viewDir, 0.0)).xyz);

    int voxelID, dist;
    vec4 finalColor = pathTrace(cameraPos.xyz, worldDir, voxelID, dist);

    imageStore(destTex, pixel_coords, finalColor);
    imageStore(voxelIDTex, pixel_coords, ivec4(voxelID, dist, 0.0, 0.0));
}