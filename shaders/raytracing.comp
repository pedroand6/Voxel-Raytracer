#version 450 core
 
// O valor normalizado (0.0-1.0) do seu flag de folha (255)
// 255.0 / 255.0 = 1.0
#define LEAF_FLAG 1.0 

// O valor normalizado do seu flag de nó interno (0)
// 0.0 / 255.0 = 0.0
#define INTERNAL_NODE_FLAG 0.0

// A dimensão da sua folha em texels (baseado no seu C++)
#define LEAF_SIZE 3

const ivec3 worldSize = ivec3(64, 64, 64);
const int MAX_RAYS = 8;
const vec4 skyColor = vec4(0.5, 0.7, 1.0, 1.0);

layout (local_size_x = 8, local_size_y = 8, local_size_z = 1) in;
layout (rgba8, binding = 0) uniform writeonly image2D destTex;

layout (std140, binding = 1) uniform Camera {
    mat4 invProjection;
    mat4 invView;
    vec4 cameraPos;
};

layout (binding = 2) uniform sampler3D u_octreeTexture;

// A dimensão da sua textura (ex: 256.0 para uma textura 256x256x256)
// Usamos float para cálculos de normalização.
uniform float u_texDim; 

// Os cantos min/max do volume total da sua octree no espaço do mundo
uniform vec3 u_worldBoundsMin;
uniform vec3 u_worldBoundsMax;


/*
 * Estrutura de Retorno
 * Contém os dados do voxel que encontramos.
 */
struct VoxelData {
    bool found;       // Se encontramos algo
    vec4 color;       // Cor (RGBA)
    vec3 properties;  // Refração, Iluminação, K
};


/*
 * Funções Auxiliares
 */

// Converte uma coordenada 3D em um índice linear 1D
int toLinear(ivec3 coord, int tex_dim_int) {
    return coord.x + coord.y * tex_dim_int + coord.z * tex_dim_int * tex_dim_int;
}

// Converte um índice linear 1D de volta para uma coordenada 3D
ivec3 fromLinear(int index, int tex_dim_int) {
    int tex_dim_sq = tex_dim_int * tex_dim_int;
    int z = index / tex_dim_sq;
    int y = (index / tex_dim_int) % tex_dim_int;
    int x = index % tex_dim_int;
    return ivec3(x, y, z);
}

// Converte um "ponteiro" (cor RGB 0.0-1.0) de volta para 
// uma coordenada inteira de texel (ex: [0, 255])
ivec3 decodePointer(vec3 pointer_rgb) {
    // Reverte a normalização
    // (o +0.5 é para arredondamento correto)
    return ivec3(pointer_rgb * 255.0 + 0.5);
}

// Substitua o 'vec3 nodeMidPoint' por 'ivec3 nodeMidPoint'
int getChildIndex(ivec3 worldPos, ivec3 nodeMidPoint) {
    int index = 0;
    // Agora é uma comparação de int com int
    if (worldPos.x > nodeMidPoint.x) index |= 4; // 100 (Direita)
    if (worldPos.y > nodeMidPoint.y) index |= 2; // 010 (Cima)
    if (worldPos.z > nodeMidPoint.z) index |= 1; // 001 (Frente)
    return index;
}

// Esta função DEVE espelhar a lógica de 'mid' e os limites do C++
// A lógica C++ é complexa, mas a divisão do cubo principal é simples:
void getChildBounds(int childIndex, inout ivec3 nodeMin, inout ivec3 nodeMax) {
    // Usa divisão de inteiros, igual ao C++
    ivec3 mid = (nodeMin + nodeMax) / 2; 
    
    // Testa o bit X (4)
    if ((childIndex & 4) == 4) { // Lado Direito (X)
        nodeMin.x = mid.x;
    } else { // Lado Esquerdo (X)
        nodeMax.x = mid.x;
    }
    // Testa o bit Y (2)
    if ((childIndex & 2) == 2) { // Lado de Cima (Y)
        nodeMin.y = mid.y;
    } else { // Lado de Baixo (Y)
        nodeMax.y = mid.y;
    }
    // Testa o bit Z (1)
    if ((childIndex & 1) == 1) { // Lado da Frente (Z)
        nodeMin.z = mid.z;
    } else { // Lado de Trás (Z)
        nodeMax.z = mid.z;
    }
}

// Converte os dados de propriedade (armazenados como 0-255) de volta
// para os valores float originais.
vec3 decodeProperties(vec4 texel) {
    // O texel aqui é (R, G, B, A) normalizado (0.0-1.0)
    
    // Revertendo a matemática do seu C++
    // C++: (uint8_t)(refraction * (255.0 / 3.0))
    // GLSL: texel.r = (refraction * (255.0 / 3.0)) / 255.0 
    //       texel.r = refraction / 3.0
    //       refraction = texel.r * 3.0
    float refraction   = texel.r * 3.0;
    
    // C++: (uint8_t)(illumination * 255.0)
    // GLSL: texel.g = (illumination * 255.0) / 255.0
    //       illumination = texel.g
    float illumination = texel.g;
    
    // C++: (uint8_t)(k * 255.0)
    // GLSL: texel.b = (k * 255.0) / 255.0
    //       k = texel.b
    float k = texel.b;
    
    return vec3(refraction, illumination, k);
}

// Obtém o texel de dados de um nó. 
// texelFetch usa coordenadas inteiras (ivec3).
vec4 getNodeData(ivec3 coord) {
    return texelFetch(u_octreeTexture, coord, 0); // 0 = nível de mipmap
}

// Substitua sua 'octreeFind' inteira por esta
VoxelData octreeFind(ivec3 worldPos) {
    VoxelData data;
    data.found = false;
    data.color = vec4(0.0);
    data.properties = vec3(0.0);

    int tex_dim_int = int(u_texDim);

    if (any(lessThan(worldPos, ivec3(0))) || 
        any(greaterThanEqual(worldPos, worldSize))) {
        return data;
    }

    ivec3 currentNodeCoord = ivec3(0, 0, 0); 
    ivec3 nodeMin = ivec3(u_worldBoundsMin);
    ivec3 nodeMax = ivec3(u_worldBoundsMax) - ivec3(1.0); // max é (63, 63, 63)
    
    for (int i = 0; i < 32; i++) {
        vec4 nodeData = getNodeData(currentNodeCoord); // Lê o Texel 0 (Cor/Flag)

        // --- É um NÓ FOLHA? ---
        if (nodeData.a >= LEAF_FLAG) {
            
            // --- INÍCIO DA CORREÇÃO (Protuberâncias) ---
            // É uma folha, mas ela representa este voxel 'worldPos'?
            
            // 1. Encontre o Texel 1 (Coordenadas)
            int linearIndex = toLinear(currentNodeCoord, tex_dim_int);
            ivec3 coordTexelCoord = fromLinear(linearIndex + 1, tex_dim_int);
            vec4 coordData = getNodeData(coordTexelCoord); // Lê (X, Y, Z, Cor.a)

            // 2. Decodifique a coordenada armazenada na folha
            //    (Use a mesma lógica de decodePointer, mas só para 3 canais)
            ivec3 leafVoxelCoord = ivec3(round(coordData.rgb * 255.0));

            // 3. Compare a coordenada da folha com a que estamos procurando
            if (!all(equal(leafVoxelCoord, worldPos))) {
                // NÃO. É uma folha, mas para um voxel diferente
                // que compartilha este nó. Trate como ar.
                return data; // Retorna data (found=false)
            }
            
            // Esta folha é exatamente o voxel que procuramos.
            data.found = true;
            data.color.rgb = nodeData.rgb; // Cor (do Texel 0)
            data.color.a = coordData.a;    // Alpha da Cor (do Texel 1)

            // 4. Encontre o Texel 2 (Propriedades)
            ivec3 propTexelCoord = fromLinear(linearIndex + 2, tex_dim_int);
            vec4 propData = getNodeData(propTexelCoord); // Lê (Ref, Ill, K, _)
            
            data.properties = decodeProperties(propData);
            return data;
            // --- FIM DA CORREÇÃO ---
        }

        // --- É um NÓ INTERNO? ---
        if (nodeData.a <= INTERNAL_NODE_FLAG) {
            // (Esta lógica já está correta)
            ivec3 pointerBlockBaseCoord = decodePointer(nodeData.rgb);
            ivec3 midPoint = (nodeMin + nodeMax) / 2;
            int childIndex = getChildIndex(worldPos, midPoint);
            
            int linearBaseIndex = toLinear(pointerBlockBaseCoord, tex_dim_int);
            ivec3 childPointerCoord = fromLinear(linearBaseIndex + childIndex, tex_dim_int);
            
            vec4 childPointerData = getNodeData(childPointerCoord);
            currentNodeCoord = decodePointer(childPointerData.rgb);
            
            if (all(equal(currentNodeCoord, ivec3(0,0,0)))) {
                return data; // Ponteiro nulo
            }

            getChildBounds(childIndex, nodeMin, nodeMax);
        }
    }
    return data; 
}

struct Ray {
    vec3 origin;
    vec3 direction;
    float IOF;
    float weight;
    bool defined;
    vec4 colorTint;
    float distanceInMedium;
    vec4 mediumColor;
    float mediumDensity;
};

bool isInsideWorld(ivec3 c) {
    return all(greaterThanEqual(c, ivec3(0))) && all(lessThan(c, worldSize));
}

bool popRay(inout Ray rays[MAX_RAYS], inout int stackSize) {
    if (stackSize <= 0) return false;
    stackSize -= 1;
    rays[stackSize].defined = false;
    return true;
}

bool addRay(inout Ray rays[MAX_RAYS], Ray ray, inout int stackSize) {
    if (!ray.defined) return false;
    if (stackSize < 0 || stackSize >= MAX_RAYS) {
        return false;
    }
    rays[stackSize] = ray;
    stackSize += 1;
    return true;
}

vec4 accumulateColors(Ray rays[MAX_RAYS]) {
    vec3 result = vec3(0.0);
    float totalWeight = 0.0;
    
    for (int i = 0; i < MAX_RAYS; ++i) {
        if (!rays[i].defined) continue;
        result += rays[i].colorTint.rgb * rays[i].weight;
        totalWeight += rays[i].weight;
    }

    if (totalWeight < 1.0 && totalWeight > 1e-6) {
        result /= totalWeight;
    } else if (totalWeight < 1e-6) {
        result = vec3(0.0); // Evita NaN
    }

    return vec4(result, 1.0);
}

bool hitMarching(in Ray thisRay, out ivec3 hitMapPos, out ivec3 prevMapPos, out vec3 hitPoint, out vec3 hitNormal, out VoxelData prevVoxel, out VoxelData hitVoxel) {
    const float EPS = 1e-6;
    vec3 origin = thisRay.origin;
    vec3 dir = normalize(thisRay.direction);

    ivec3 mapPos = ivec3(floor(origin));
    prevMapPos = mapPos;
    hitVoxel = octreeFind(mapPos);
    prevVoxel = hitVoxel;

    ivec3 stepSign = ivec3(sign(dir));

    vec3 tDelta = vec3(
        abs(dir.x) > EPS ? abs(1.0 / dir.x) : 1e30,
        abs(dir.y) > EPS ? abs(1.0 / dir.y) : 1e30,
        abs(dir.z) > EPS ? abs(1.0 / dir.z) : 1e30
    );

    vec3 voxelBoundary = floor(origin) + vec3(step(0.0, dir.x), step(0.0, dir.y), step(0.0, dir.z));

    vec3 tMax = vec3(
        abs(dir.x) > EPS ? (voxelBoundary.x - origin.x) / dir.x : 1e30,
        abs(dir.y) > EPS ? (voxelBoundary.y - origin.y) / dir.y : 1e30,
        abs(dir.z) > EPS ? (voxelBoundary.z - origin.z) / dir.z : 1e30
    );

    for (int i = 0; i < 1024; ++i) {
        int axis = 0;
        if (tMax.x < tMax.y) {
            axis = (tMax.x < tMax.z) ? 0 : 2;
        } else {
            axis = (tMax.y < tMax.z) ? 1 : 2;
        }

        float tHit = 0.0;
        if (axis == 0) {
            mapPos.x += stepSign.x;
            tHit = tMax.x;
            tMax.x += tDelta.x;
        } else if (axis == 1) {
            mapPos.y += stepSign.y;
            tHit = tMax.y;
            tMax.y += tDelta.y;
        } else {
            mapPos.z += stepSign.z;
            tHit = tMax.z;
            tMax.z += tDelta.z;
        }

        prevMapPos = mapPos - stepSign * ((axis==0) ? ivec3(1,0,0) : (axis==1 ? ivec3(0,1,0) : ivec3(0,0,1)));
        
        prevVoxel = hitVoxel;
        hitVoxel = octreeFind(mapPos);

        float prevRefrac = (prevVoxel.found && prevVoxel.properties[0] > 0.0) ? prevVoxel.properties[0] : thisRay.IOF;
    
        // Obtenha o IOR do voxel que acabamos de ENTRAR.
        // Se não for encontrado ou IOR <= 0, trate como ar (1.0).
        float currentRefrac = (hitVoxel.found && hitVoxel.properties[0] > 0.0) ? hitVoxel.properties[0] : 1.0;

        bool refracChanged = abs(currentRefrac - prevRefrac) > 1e-4;

        // A verificação agora é feita FORA do "if (hitVoxel.found)"
        if (refracChanged && tHit > 1e-5) {
            hitMapPos = mapPos;
            hitPoint = origin + dir * tHit;
            if (axis == 0) hitNormal = vec3(-float(stepSign.x), 0.0, 0.0);
            else if (axis == 1) hitNormal = vec3(0.0, -float(stepSign.y), 0.0);
            else hitNormal = vec3(0.0, 0.0, -float(stepSign.z));
            return true;
        }
    }

    return false;
}

vec4 raymarching_fromDir(vec3 rayOrigin, vec3 rayDir) {
    ivec3 thisMapPos = ivec3(floor(rayOrigin));
    VoxelData thisVoxel = octreeFind(thisMapPos);
    float startIOF = 1.0;
    if (thisVoxel.found && thisVoxel.properties[0] > 0.0) {
        startIOF = thisVoxel.properties[0];
    }

    Ray rayStack[MAX_RAYS];
    Ray resultRays[MAX_RAYS];
    for (int i = 0; i < MAX_RAYS; ++i){
        rayStack[i].defined = false;
        resultRays[i].defined = false;
        resultRays[i].weight = 0.0;
        resultRays[i].colorTint = vec4(0.0);
    }

    rayStack[0].origin = rayOrigin;
    rayStack[0].direction = normalize(rayDir);
    rayStack[0].IOF = startIOF;
    rayStack[0].defined = true;
    rayStack[0].weight = 1.0;
    rayStack[0].colorTint = vec4(1.0);
    rayStack[0].distanceInMedium = 0.0;
    rayStack[0].mediumColor = vec4(1.0);
    rayStack[0].mediumDensity = 0.0;
    int stackSize = 1;
    int resultSize = 0;

    while (stackSize > 0) {
        int rayIndex = stackSize - 1;
        Ray currentRay = rayStack[rayIndex];
        vec3 rayStartPoint = currentRay.origin;
        popRay(rayStack, stackSize);

        if (!currentRay.defined) continue;

        ivec3 mapPos, prevMapPos;
        vec3 hitPoint, hitNormal;
        VoxelData lastVoxel;
        bool hit = hitMarching(currentRay, mapPos, prevMapPos, hitPoint, hitNormal, lastVoxel, thisVoxel);

        if (!hit) {
            Ray finalRay;
            finalRay.defined = true;
            finalRay.weight = currentRay.weight;
            
            // Apply Beer's Law absorption for the final segment
            vec4 transmittedColor = currentRay.colorTint;
            float distanceTraveled = currentRay.distanceInMedium;
            if (distanceTraveled > 1e-6 && currentRay.mediumDensity > 0.0) {
                vec3 absorption = exp(-currentRay.mediumDensity * distanceTraveled * (vec3(1.0) - currentRay.mediumColor.rgb));
                transmittedColor.rgb *= absorption;
            }
            
            // Blend with sky color
            finalRay.colorTint = transmittedColor * skyColor;
            addRay(resultRays, finalRay, resultSize);
            continue;
        }

        // Update distance traveled through current medium
        float segmentDistance = length(hitPoint - rayStartPoint);
        currentRay.distanceInMedium += segmentDistance;

        vec4 voxelColor;

        if (thisVoxel.found) {
            voxelColor = thisVoxel.color;
        } else {
            thisVoxel.properties = vec3(1.0, 0.0, 0.0); // 1.0 IOF, 0.0 illumination, 0.0 mettalicity
            voxelColor = vec4(0.0);
        }

        vec4 lastVoxelColor;
        if (lastVoxel.found) {
            lastVoxelColor = lastVoxel.color;
        } else {
            lastVoxel.properties = currentRay.IOF > 0.0 ? vec3(0.0, 0.0, 0.0) : vec3(1.0, 0.0, 0.0); // 1.0 IOF, 0.0 illumination, 0.0 mettalicity
            lastVoxelColor = vec4(0.0);
        }

        vec3 normal = hitNormal;
        if (length(normal) == 0.0) normal = vec3(0.0, 1.0, 0.0);

        vec3 lightDir = normalize(vec3(0.4, 1.0, 0.4));

        float ambientStrength = 0.2;
        vec3 ambient = vec3(ambientStrength);

        float diff = max(dot(normal, lightDir), 0.0);
        vec3 diffuse = vec3(diff);

        // Shadow check
        Ray lightRay;
        lightRay.origin = hitPoint + normal * 1e-3;
        lightRay.direction = lightDir;
        lightRay.IOF = currentRay.IOF;
        lightRay.defined = true;

        ivec3 shadowHit, shadowPrev;
        vec3 shadowPoint, shadowNormal;
        VoxelData lastShadowVox, hitShadowVox;
        if (hitMarching(lightRay, shadowHit, shadowPrev, shadowPoint, shadowNormal, lastShadowVox, hitShadowVox)) {
            diffuse = vec3(0.0);
        }

        vec3 finalLight = ambient + diffuse;
        
        // Determine surface color based on which side we're hitting
        vec4 surfaceColor;
        float surfaceAlpha;
        if (voxelColor.a > 0.0) {
            surfaceColor = voxelColor;
            surfaceAlpha = voxelColor.a;
        } else {
            surfaceColor = lastVoxelColor;
            surfaceAlpha = lastVoxelColor.a;
        }

        float refracIndex = thisVoxel.properties[0] > 0.0 ? thisVoxel.properties[0] : 1.0;
        float prevRefracIndex = lastVoxel.properties[0] > 0.0 ? lastVoxel.properties[0] : 1.0;

        vec3 incidentDir = normalize(currentRay.direction);
        vec3 n = normal;

        // Apply Beer's Law absorption for distance traveled so far
        vec4 transmittedColor = currentRay.colorTint;
        float distanceTraveled = currentRay.distanceInMedium;
        if (distanceTraveled > 1e-6 && currentRay.mediumDensity > 0.0) {
            vec3 absorption = exp(-currentRay.mediumDensity * distanceTraveled * (vec3(1.0) - currentRay.mediumColor.rgb));
            transmittedColor.rgb *= absorption;
        }

        // === TRANSPARENT/TRANSLUCENT SURFACES ===
        if (surfaceAlpha < 1) {
            float cosi = dot(incidentDir, n);
            float n1 = prevRefracIndex;
            float n2 = refracIndex;
            if (cosi > 0.0) {
                n = -n;
                float tmp = n1;
                n1 = n2;
                n2 = tmp;
            }
            float eta = n1 / n2;
            vec3 refractDir = refract(incidentDir, n, eta);
            vec3 reflectDir = reflect(incidentDir, n);

            float R0 = pow((n1 - n2) / (n1 + n2), 2.0);
            float cosTheta = max(0.0, dot(-incidentDir, n));
            float fresnel = R0 + (1.0 - R0) * pow(1.0 - cosTheta, 5.0);
            fresnel = clamp(fresnel, 0.0, 1.0);

            bool hasTIR = length(refractDir) < 0.001;
            float reflectIntensity = fresnel;
            float refractIntensity = hasTIR ? 0.0 : (1.0 - fresnel);

            // DONT WASTE ENERGY YOU SICK FUCK
            if(stackSize == MAX_RAYS || reflectIntensity <= 0.001 || refractIntensity <= 0.001){
                vec4 litSurfaceColor = vec4(surfaceColor.rgb * finalLight, 1.0);
                Ray finalRay;
                finalRay.defined = true;
                finalRay.weight = currentRay.weight;
                finalRay.colorTint = transmittedColor * litSurfaceColor;
                
                addRay(resultRays, finalRay, resultSize);
                continue;
            }

            // ---- Reflection ray ----
            if (reflectIntensity > 0.001 && stackSize < MAX_RAYS) {
                Ray reflectionRay;
                reflectionRay.direction = reflectDir;
                reflectionRay.origin = hitPoint + n * 1e-4;
                reflectionRay.defined = true;
                reflectionRay.IOF = n1;
                reflectionRay.weight = currentRay.weight * reflectIntensity;
                reflectionRay.colorTint = transmittedColor;
                
                // Going back into previous medium
                reflectionRay.distanceInMedium = 0.0;
                reflectionRay.mediumColor = lastVoxelColor;
                reflectionRay.mediumDensity = lastVoxelColor.a * 5.0;
                
                if (reflectionRay.weight > 1e-4)
                    addRay(rayStack, reflectionRay, stackSize);
            }

            // ---- Refraction ray ----
            if (refractIntensity > 0.001 && stackSize < MAX_RAYS && !hasTIR) {
                Ray refractionRay;
                refractionRay.direction = refractDir;
                refractionRay.origin = hitPoint - n * 1e-4;
                refractionRay.defined = true;
                refractionRay.IOF = n2;
                refractionRay.weight = currentRay.weight * refractIntensity;
                refractionRay.colorTint = transmittedColor;
                
                // Entering new medium
                refractionRay.distanceInMedium = 0.0;
                refractionRay.mediumColor = voxelColor;
                refractionRay.mediumDensity = voxelColor.a * 5.0;
                
                if (refractionRay.weight > 1e-4)
                    addRay(rayStack, refractionRay, stackSize);
            }
        }
        else {
            // === OPAQUE SURFACE ===
            float specularFactor = thisVoxel.properties[2];
            float diffuseFactor = 1.0 - specularFactor;

            vec4 litSurfaceColor = vec4(surfaceColor.rgb * finalLight, 1.0);

            // Diffuse component
            if (diffuseFactor > 0.01) {
                Ray finalRay;
                finalRay.defined = true;
                finalRay.weight = currentRay.weight * diffuseFactor;
                finalRay.colorTint = transmittedColor * litSurfaceColor;
                
                addRay(resultRays, finalRay, resultSize);
            }

            // Specular reflection
            if (specularFactor > 0.01 && stackSize < MAX_RAYS) {
                vec3 reflectDir = reflect(incidentDir, normal);
                Ray reflectionRay;
                reflectionRay.direction = reflectDir;
                reflectionRay.origin = hitPoint + normal * 1e-4;
                reflectionRay.defined = true;
                reflectionRay.IOF = prevRefracIndex;
                reflectionRay.weight = currentRay.weight * specularFactor;
                reflectionRay.colorTint = transmittedColor;
                reflectionRay.distanceInMedium = 0.0;
                reflectionRay.mediumColor = vec4(1.0);
                reflectionRay.mediumDensity = 0.0;
                
                if (reflectionRay.weight > 1e-4)
                    addRay(rayStack, reflectionRay, stackSize);
            }
        }
    }
    
    return accumulateColors(resultRays);
}

void main() {
    ivec2 pixel_coords = ivec2(gl_GlobalInvocationID.xy);
    ivec2 dims = imageSize(destTex);

    if (pixel_coords.x < 0 || pixel_coords.x >= dims.x || pixel_coords.y < 0 || pixel_coords.y >= dims.y) return;

    float u = (float(pixel_coords.x) / float(dims.x)) * 2.0 - 1.0;
    float v = (float(pixel_coords.y) / float(dims.y)) * 2.0 - 1.0;

    vec4 clip = vec4(u, v, -1.0, 1.0);
    vec4 view = invProjection * clip;
    if (abs(view.w) > 1e-6) view /= view.w;
    vec3 viewDir = normalize(view.xyz);
    vec3 worldDir = normalize((invView * vec4(viewDir, 0.0)).xyz);

    vec4 finalColor = raymarching_fromDir(cameraPos.xyz, worldDir);

    if (length(finalColor.rgb) == 0.0) finalColor = skyColor;

    imageStore(destTex, pixel_coords, finalColor);
}