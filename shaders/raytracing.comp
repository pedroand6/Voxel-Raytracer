#version 450 core

// Tamanho do grupo de trabalho. 8x8 = 64 threads por grupo
layout (local_size_x = 8, local_size_y = 8, local_size_z = 1) in;

// A textura de saída onde vamos desenhar.
// O 'binding = 0' corresponde ao glBindImageTexture(0, ...).
layout (rgba8, binding = 0) uniform writeonly image2D destTex;

// UBO com os dados da câmera
layout (std140, binding = 1) uniform Camera {
    mat4 invProjection;
    mat4 invView;
    vec3 cameraPos;
};

// Dimensões do nosso mundo de voxels
const ivec3 worldSize = ivec3(64, 64, 64);

// Conversão das cores para o sistema de vector4
uint get_red_rgba(uint color) {
    uint red = (color >> 24) & 0xff;
    return red;
}

uint get_green_rgba(uint color) {
    uint green = (color >> 16) & 0xff;
    return green;
}

uint get_blue_rgba(uint color) {
    uint blue = (color >> 8) & 0xff;
    return blue;
}

uint get_alpha_rgba(uint color) {
    uint alpha = color & 0xff;
    return alpha;
}

vec4 rgbaColor(uint color) {
    return vec4(
        float(get_red_rgba(color))/ float(0xff),
        float(get_green_rgba(color))/ float(0xff),
        float(get_blue_rgba(color))/ float(0xff),
        float(get_alpha_rgba(color))/ float(0xff)
    );
}

// SSBO com os dados dos voxels
// O 'binding = 2' corresponde ao glBindBufferBase(..., 2, ...).

// Enum for Voxel Types
const uint VOX_AIR = 0;
const uint VOX_GRASS = 1;
const uint VOX_DIRT = 2;
const uint VOX_STONE = 3;
const uint VOX_WATER = 4;

struct Voxel {
    uint type;
    float refraction;
};

struct VoxelObj {
    ivec3 coord;
    uint color; // uint32
    Voxel voxel;

    uint padding[2];
};

layout (std430, binding = 2) buffer VoxelBuffer {
    VoxelObj voxels[];
};

vec3 map(vec3 value, vec3 min1, vec3 max1, vec3 min2, vec3 max2) {
  return min2 + (value - min1) * (max2 - min2) / (max1 - min1);
}

// Pegar o indice pela coordenada 3D
int getVoxelIndex(ivec3 coord) {
    return coord.x + coord.y * worldSize.x + coord.z * worldSize.x * worldSize.y;
}

// Função para obter um voxel de uma coordenada 3D
// Retorna a cor se o voxel for sólido (alfa > 0), senão vec4(0)
vec4 getVoxelColor(ivec3 coord) {
    // Verifica se a coordenada está dentro dos limites do mundo
    if (any(lessThan(coord, ivec3(0))) || any(greaterThanEqual(coord, worldSize))) {
        return vec4(0.0);
    }
    
    // Converte coordenada 3D para um índice 1D
    int index = getVoxelIndex(coord);

    vec4 voxelColor = rgbaColor(voxels[index].color);
    if (voxelColor.a > 0.0) { // Consideramos alfa > 0 como um voxel sólido
        return voxelColor;
    }
    
    return vec4(0.0);
}

bool isInShadow(vec3 rayOrigin, vec3 rayDir) {
    vec3 rayStep = sign(rayDir);
    vec3 tDelta = abs(1.0 / rayDir);
    vec3 voxelBoundary = floor(rayOrigin) + step(0.0, rayDir);
    vec3 tMax = (voxelBoundary - rayOrigin) / rayDir;
    ivec3 mapPos = ivec3(floor(rayOrigin));

    int index = getVoxelIndex(mapPos);

    // Marchamos pelo grid (por uma distância máxima para a sombra)
    for (int i = 0; i < 128; i++) {
        if (getVoxelColor(mapPos).a > 0.0 && getVoxelIndex(mapPos) != index) {
            return true;
        }

        // avançamos para o próximo voxel
        if (tMax.x < tMax.y) {
            if (tMax.x < tMax.z) {
                mapPos.x += int(rayStep.x); tMax.x += tDelta.x;
            } else {
                mapPos.z += int(rayStep.z); tMax.z += tDelta.z;
            }
        } else {
            if (tMax.y < tMax.z) {
                mapPos.y += int(rayStep.y); tMax.y += tDelta.y;
            } else {
                mapPos.z += int(rayStep.z); tMax.z += tDelta.z;
            }
        }
    }

    return false;
}

vec4 redirectRay (vec3 rayOrigin, vec3 rayDir, float refractionIndex) {
    vec3 rayStep = sign(rayDir);
    vec3 tDelta = abs(1.0 / rayDir);
    vec3 voxelBoundary = floor(rayOrigin) + step(0.0, rayDir);
    vec3 tMax = (voxelBoundary - rayOrigin) / rayDir;
    ivec3 mapPos = ivec3(floor(rayOrigin));
    ivec3 prevMapPos = mapPos;

    vec4 finalColor = vec4(0.0);

    // Marchamos pelo grid (por uma distância máxima)
    for (int i = 0; i < 128; i++) {

        // avançamos para o próximo voxel
        if (tMax.x < tMax.y) {
            if (tMax.x < tMax.z) {
                mapPos.x += int(rayStep.x); tMax.x += tDelta.x;
            } else {
                mapPos.z += int(rayStep.z); tMax.z += tDelta.z;
            }
        } else {
            if (tMax.y < tMax.z) {
                mapPos.y += int(rayStep.y); tMax.y += tDelta.y;
            } else {
                mapPos.z += int(rayStep.z); tMax.z += tDelta.z;
            }
        }

        vec4 voxelColor = getVoxelColor(mapPos);

        if (voxelColor.a > 0.0) {
            vec3 normal = normalize(sign(vec3(prevMapPos - mapPos)));
            if (length(normal) == 0.0) normal = vec3(0.0, 1.0, 0.0); // fallback

            vec3 lightDir = normalize(vec3(0.4, 1.0, 0.4));
            vec3 rayContact = vec3(mapPos) + normal;

            // Luz ambiente
            float ambientStrength = 0.2;
            vec3 ambient = vec3(ambientStrength);

            // Contribuição da luz direta (difusa)
            //    max(..., 0.0) impede que faces opostas à luz fiquem com iluminação negativa
            float diff = max(dot(normal, lightDir), 0.0);
            vec3 diffuse = vec3(diff);

            if (isInShadow(rayContact, lightDir)) {
                diffuse = vec3(0.0); // Se estiver em sombra, anula a contribuição da luz direta
            }

            vec3 finalLight = ambient + diffuse;
            voxelColor = vec4(voxelColor.rgb * finalLight, voxelColor.a);
        }

        if (voxelColor.a > 0.0 && voxels[getVoxelIndex(mapPos)].voxel.refraction != refractionIndex ) {
            return voxelColor;
        }

        prevMapPos = mapPos;
    }

    return vec4(0.5, 0.7, 1.0, 1.0); // Cor do céu (azul claro)
}

vec4 raymarching(vec4 target, vec3 rayOrigin) {
    vec3 rayDir = vec3(invView * vec4(normalize(target.xyz), 0.0));

    // --- Algoritmo de Travessia de Voxel (DDA Simplificado) ---
    vec3 rayStep = sign(rayDir);
    vec3 tDelta = abs(1.0 / rayDir);
    vec3 voxelBoundary = floor(rayOrigin) + step(0.0, rayDir);
    vec3 tMax = (voxelBoundary - rayOrigin) / rayDir;
    ivec3 mapPos = ivec3(floor(rayOrigin));
    ivec3 prevMapPos = mapPos;

    bool hit = false;
    vec4 finalColor = vec4(0.0);

    // Marcha pelo grid por um número máximo de passos
    for (int i = 0; i < 512; i++) {
        int index = getVoxelIndex(mapPos);
        VoxelObj thisVoxel = voxels[index];
        vec4 voxelColor = getVoxelColor(mapPos);
        
        if (voxelColor.a > 0.0) {
            vec3 normal = normalize(sign(vec3(prevMapPos - mapPos)));
            if (length(normal) == 0.0) normal = vec3(0.0, 1.0, 0.0); // fallback

            vec3 lightDir = normalize(vec3(0.4, 1.0, 0.4));
            vec3 rayContact = vec3(mapPos) + normal;

            // Luz ambiente
            float ambientStrength = 0.2;
            vec3 ambient = vec3(ambientStrength);

            // Contribuição da luz direta (difusa)
            //    max(..., 0.0) impede que faces opostas à luz fiquem com iluminação negativa
            float diff = max(dot(normal, lightDir), 0.0);
            vec3 diffuse = vec3(diff);

            if (isInShadow(rayContact, lightDir)) {
                diffuse = vec3(0.0); // Se estiver em sombra, anula a contribuição da luz direta
            }

            vec3 finalLight = ambient + diffuse;
            finalColor = vec4(voxelColor.rgb * finalLight, voxelColor.a);
            
            float refracIndex = thisVoxel.voxel.refraction;
            if(thisVoxel.voxel.refraction != 1.0) {
                // REFRACAO
                vec3 refractDir = refract(normalize(rayDir), normal, 1.0 / refracIndex);

                // REFLEXAO
                vec3 reflectDir = reflect(normalize(rayDir), normal);

                // FRESNEL (Aproximação de Schlick)
                float n1 = 1.0; // Indice do ar
                float n2 = refracIndex;
                float R0 = pow((n1 - n2) / (n1 + n2), 2.0); // Lei de Snell (incidencia normal)
                
                float cosTheta = max(0.0, dot(-normalize(rayDir), normal));

                float reflectIntensity = R0 + (1.0 - R0) * pow(1.0 - cosTheta, 5.0);

                vec4 refractionColor = redirectRay(rayContact, refractDir, refracIndex);
                vec4 reflectionColor = redirectRay(rayContact, reflectDir, refracIndex);

                vec4 lightmap = mix(refractionColor, reflectionColor, reflectIntensity);
                finalColor = mix(lightmap, finalColor, 0.5);
            }


            hit = true;
            break;
        }

        prevMapPos = mapPos;
        
        // Avança para o próximo voxel (lógica DDA)
        if (tMax.x < tMax.y) {
            if (tMax.x < tMax.z) {
                mapPos.x += int(rayStep.x);
                tMax.x += tDelta.x;
            } else {
                mapPos.z += int(rayStep.z);
                tMax.z += tDelta.z;
            }
        } else {
            if (tMax.y < tMax.z) {
                mapPos.y += int(rayStep.y);
                tMax.y += tDelta.y;
            } else {
                mapPos.z += int(rayStep.z);
                tMax.z += tDelta.z;
            }
        }
    }

    return finalColor;
}

void main() {
    // Coordenada do pixel para o qual este thread é responsável
    ivec2 pixel_coords = ivec2(gl_GlobalInvocationID.xy);
    ivec2 dims = imageSize(destTex); // Pega o tamanho da textura

    // Normaliza as coordenadas do pixel para o intervalo [-1, 1]
    float u = (float(pixel_coords.x) / float(dims.x)) * 2.0 - 1.0;
    float v = (float(pixel_coords.y) / float(dims.y)) * 2.0 - 1.0;

    // --- Geração do Raio ---
    // Transforma as coordenadas da tela para o espaço do mundo
    vec4 target = invProjection * vec4(u, v, 1.0, 1.0);
    vec4 finalColor = raymarching(target, cameraPos);

    if(finalColor.a == 0.0) {
        finalColor = vec4(0.5, 0.7, 1.0, 1.0); // Cor do céu (azul claro)
    }

    // Escreve a cor final na textura de saída
    imageStore(destTex, pixel_coords, finalColor);
}