#version 450 core
 
// O valor normalizado (0.0-1.0) do seu flag de folha (255)
// 255.0 / 255.0 = 1.0
#define LEAF_FLAG 1.0 

// O valor normalizado do seu flag de nó interno (0)
// 0.0 / 255.0 = 0.0
#define INTERNAL_NODE_FLAG 0.0

// A dimensão da sua folha em texels (baseado no seu C++)
#define LEAF_SIZE 3

const ivec3 worldSize = ivec3(256, 256, 256);
const int MAX_RAYS = 8;
const vec4 skyColor = vec4(0.5, 0.7, 1.0, 1.0);

layout (local_size_x = 8, local_size_y = 8, local_size_z = 1) in;
layout (rgba8, binding = 0) uniform writeonly image2D destTex;

layout (std140, binding = 1) uniform Camera {
    mat4 invProjection;
    mat4 invView;
    vec4 cameraPos;
};

layout (binding = 2) uniform sampler3D u_octreeTexture;

// A dimensão da sua textura (ex: 256.0 para uma textura 256x256x256)
uniform int u_texDim;

// Os cantos min/max do volume total da sua octree no espaço do mundo
uniform ivec3 u_worldBoundsMin;
uniform ivec3 u_worldBoundsMax;

/*
 * Estrutura de Retorno
 * Contém os dados do voxel que encontramos.
 */
struct VoxelData {
    lowp vec4 color;       // Cor (RGBA)
    lowp vec3 properties;  // Refração, Iluminação, K
    int size;
};

/*
 * Estrutura de Raio
 * Usada para rastreamento de raios.
 */
struct Ray {
    vec3 origin;
    vec3 direction;
    float IOF;
    float weight;
    bool defined;
    lowp vec4 colorTint;
    float distanceInMedium;
    lowp vec4 mediumColor;
    lowp float mediumDensity;
};


/*
 * Funções Auxiliares
 */

// Converte uma coordenada 3D em um índice linear 1D
int toLinear(ivec3 coord) {
    return coord.x + u_texDim * (coord.y + u_texDim * coord.z);
}

// Converte um índice linear 1D de volta para uma coordenada 3D
ivec3 fromLinear(int index) {
    int tex_dim_sq = u_texDim * u_texDim;
    int z = index / tex_dim_sq;
    int rem = index - z * tex_dim_sq;
    int y = rem / u_texDim;
    int x = rem - y * u_texDim;
    return ivec3(x, y, z);
}

// Converte um "ponteiro" (cor RGB 0.0-1.0) de volta para 
// uma coordenada inteira de texel (ex: [0, 255])
ivec3 decodePointer(vec3 pointer_rgb) {
    // Reverte a normalização
    // (o +0.5 é para arredondamento correto)
    return ivec3(pointer_rgb * 255.0 + 0.5);
}

// Substitua o 'vec3 nodeMidPoint' por 'ivec3 nodeMidPoint'
int getchildIndices(ivec3 worldPos, ivec3 nodeMidPoint) {
    // O ponto médio calculado por divisão de inteiros é o INÍCIO do bloco da direita.
    int gx = int(worldPos.x > nodeMidPoint.x);
    int gy = int(worldPos.y > nodeMidPoint.y);
    int gz = int(worldPos.z > nodeMidPoint.z);
    return gx * 4 + gy * 2 + gz;
}

// Esta função DEVE espelhar a lógica de 'mid' e os limites do C++
// A lógica C++ é complexa, mas a divisão do cubo principal é simples:
void getChildBounds(int childIndices, inout ivec3 nodeMin, inout ivec3 nodeMax) {
    // Calcula o último voxel da metade "inferior"
    ivec3 mid = (nodeMin + nodeMax) / 2; 

    // GPU por algum motivo prefere com operador ternário dessa forma?
    if ((childIndices & 4) != 0) nodeMin.x = mid.x + 1; else nodeMax.x = mid.x;
    if ((childIndices & 2) != 0) nodeMin.y = mid.y + 1; else nodeMax.y = mid.y;
    if ((childIndices & 1) != 0) nodeMin.z = mid.z + 1; else nodeMax.z = mid.z;
}

// Converte os dados de propriedade (armazenados como 0-255) de volta
// para os valores float originais.
vec3 decodeProperties(vec4 texel) {
    return vec3(texel.r * 3.0, texel.g, texel.b);
}

// Obtém o texel de dados de um nó. 
// texelFetch usa coordenadas inteiras (ivec3).
vec4 getNodeData(ivec3 coord) {
    return texelFetch(u_octreeTexture, coord, 0); // 0 = nível de mipmap
}

VoxelData octreeFind(ivec3 worldPos) {
    VoxelData data;
    data.color = vec4(0.0);
    data.properties = vec3(0.0);
    data.size = 1;

    // Early boundary check
    if (worldPos.x < 0 || worldPos.y < 0 || worldPos.z < 0 ||
        worldPos.x >= worldSize.x || worldPos.y >= worldSize.y || worldPos.z >= worldSize.z) {
        return data;
    }

    ivec3 currentNodeCoord = ivec3(0);
    ivec3 nodeMin = u_worldBoundsMin;
    ivec3 nodeMax = u_worldBoundsMax;
    int currentSize = worldSize.x; // Começa com o tamanho total
    
    for (int i = 0; i < 16; i++) {
        vec4 nodeData = getNodeData(currentNodeCoord); // Lê o Texel 0 (Cor/Flag)

        // É um nó folha?
        if (nodeData.a >= LEAF_FLAG) {            
            // 1. Encontre o Texel 1 (Coordenadas)
            int linearIndex = toLinear(currentNodeCoord);
            ivec3 coordTexelCoord = fromLinear(linearIndex + 1);
            vec4 coordData = getNodeData(coordTexelCoord); // Lê (X, Y, Z, Cor.a)

            // Decodifique a coordenada armazenada na folha
            // (Use a mesma lógica de decodePointer, mas só para 3 canais)
            ivec3 leafVoxelCoord = ivec3(coordData.rgb * 255.0 + 0.5);
            
            // Compare a coordenada da folha com a que estamos procurando
            if (all(equal(leafVoxelCoord, worldPos))) {
                // Esta folha é exatamente o voxel que procuramos.
                data.color.rgb = nodeData.rgb;  // Cor (do Texel 0)
                data.color.a = coordData.a;     // Alpha da Cor (do Texel 1)
                
                ivec3 propTexelCoord = fromLinear(linearIndex + 2); // Lê (Ref, Ill, K, _)
                vec4 propData = getNodeData(propTexelCoord);
                data.properties = decodeProperties(propData);
                data.size = currentSize;
                return data;
            }

            return data; // Não é o voxel que procuramos
        }

        // É um nó interno?
        if (nodeData.a <= INTERNAL_NODE_FLAG) {
            ivec3 pointerBlockBaseCoord = decodePointer(nodeData.rgb); // Pega a coordenada do primeiro filho deste nó (quando igual a (0,0,0) retorna (0,0,0))
            ivec3 midPoint = (nodeMin + nodeMax) / 2; // Calcula o voxel médio
            int childIndices = getchildIndices(worldPos, midPoint); // Determina o índice do filho em que o voxel está
            
            int linearBaseIndex = toLinear(pointerBlockBaseCoord); // Índice linear do primeiro filho
            ivec3 childPointerCoord = fromLinear(linearBaseIndex + childIndices); // Coordenada do filho específico (primeiro filho + indice do filho (0 até 7))
            
            vec4 childPointerData = getNodeData(childPointerCoord); // Lê o Texel 0 do filho em que o voxel está (Ponteiro RGB + Flag A)
            ivec3 nextNode = decodePointer(childPointerData.rgb); // Pega a coordenada do primeiro filho do filho do nó anterior

            // Sai antes pra quando tiver vazio
            if (all(equal(nextNode, ivec3(0)))) {
                data.size = currentSize / 2;
                return data;
            }

            currentNodeCoord = nextNode;
            currentSize = max(1, currentSize / 2); // Reduz o tamanho atual pela metade
            getChildBounds(childIndices, nodeMin, nodeMax); // Atualiza os limites do nó atual
            continue;
        }

        // se estrutura corrompida, sai
        return data;
    }

    return data;
}

// --- Raymarching ---

bool isInsideWorld(ivec3 c) {
    return (c.x >= 0) && (c.y >= 0) && (c.z >= 0) &&
           (c.x < worldSize.x) && (c.y < worldSize.y) && (c.z < worldSize.z);
}

bool addRay(inout Ray rays[MAX_RAYS], Ray ray, inout int stackSize) {
    if (!ray.defined || stackSize >= MAX_RAYS) return false;
    rays[stackSize++] = ray;
    return true;
}

vec4 accumulateColors(Ray rays[MAX_RAYS], int rayCount) {
    vec3 result = vec3(0.0);
    float totalWeight = 0.0;
    
    for (int i = 0; i < rayCount; ++i) {
        if (!rays[i].defined) continue;
        result += rays[i].colorTint.rgb * rays[i].weight;
        totalWeight += rays[i].weight;
    }

    return totalWeight > 1e-6 ? vec4(result / max(totalWeight, 1.0), 1.0) : vec4(0.0, 0.0, 0.0, 1.0);
}

bool hitMarching(in Ray thisRay, out ivec3 hitMapPos, out ivec3 prevMapPos, out vec3 hitPoint, out vec3 hitNormal, out VoxelData prevVoxel, out VoxelData hitVoxel) {
    
    vec3 rayPos = thisRay.origin;
    float invLen = inversesqrt(dot(thisRay.direction, thisRay.direction));
    vec3 rayDir = thisRay.direction * invLen;

    // Epsilon pequeno para cruzar a fronteira
    const float DIR_EPSILON = 1e-8;
    const float EPS = 0.0001;
    
    // Evita divisão por zero
    vec3 invDir;
    invDir.x = (abs(rayDir.x) < DIR_EPSILON) ? 1e20 : 1.0 / rayDir.x;
    invDir.y = (abs(rayDir.y) < DIR_EPSILON) ? 1e20 : 1.0 / rayDir.y;
    invDir.z = (abs(rayDir.z) < DIR_EPSILON) ? 1e20 : 1.0 / rayDir.z;

    // Pega o estado inicial
    ivec3 mapPos = ivec3(floor(rayPos));
    hitVoxel = octreeFind(mapPos);
    
    // Inicializa prevVoxel na primeira iteração
    prevVoxel = hitVoxel;
    
    // Define um limite de segurança para o loop
    for (int i = 0; i < 256; ++i) {
        // 1. Onde estamos?
        // Precisamos alinhar a caixa atual com o tamanho retornado pela Octree
        // Isso é matemática de bitwise (ou float) para alinhar à grade.
        float sizeF = max(1.0, float(hitVoxel.size));
        int isize = int(sizeF);
        
        // Acha o canto inferior (min) do cubo atual alinhado ao tamanho 'size'
        ivec3 voxelMin = (mapPos / isize) * isize;
        vec3 boxMin = vec3(voxelMin);
        vec3 boxMax = boxMin + vec3(sizeF);
        
        // 2. Calcule a distância para sair deste cubo (Ray-Box Exit)
        // (Similar ao tMax do DDA, mas para a caixa atual inteira)
        vec3 pickMax;
        pickMax.x = (rayDir.x > 0.0) ? boxMax.x : boxMin.x;
        pickMax.y = (rayDir.y > 0.0) ? boxMax.y : boxMin.y;
        pickMax.z = (rayDir.z > 0.0) ? boxMax.z : boxMin.z;
        vec3 tMax = (pickMax - rayPos) * invDir;
        
        // 3. Descubra qual face atingimos primeiro (o menor t)
        // Isso nos dá a NORMAL e a distância do passo.
        float tStep;
        int axis;
        
        if (tMax.x < tMax.y && tMax.x < tMax.z) {
            tStep = tMax.x;
            axis = 0;
            hitNormal = vec3(-sign(rayDir.x), 0.0, 0.0);
        } else if (tMax.y < tMax.z) {
            tStep = tMax.y;
            axis = 1;
            hitNormal = vec3(0.0, -sign(rayDir.y), 0.0);
        } else {
            tStep = tMax.z;
            axis = 2;
            hitNormal = vec3(0.0, 0.0, -sign(rayDir.z));
        }
        
        // Avança o raio para EXATAMENTE a borda
        // Nota: O 'tStep' é a distância geométrica exata até a parede.
        rayPos += rayDir * tStep;
        vec3 hitEndPoint = rayPos;

        // Empurra APENAS o eixo que bateu para dentro do próximo voxel
        rayPos[axis] += sign(rayDir[axis]) * EPS;

        // Atualiza a posição inteira para buscar o próximo voxel
        prevMapPos = mapPos;
        mapPos = ivec3(floor(rayPos));
        
        // Verifica se saiu do mundo
        if (!isInsideWorld(mapPos)) return false;

        // Salva o estado anterior antes de atualizar
        prevVoxel = hitVoxel;
        // Busca o NOVO voxel na nova posição
        hitVoxel = octreeFind(mapPos);
        
        // 5. Verifica mudança de meio (lógica de Hit)
        float prevRefrac = (prevVoxel.color.a > 0.0 && prevVoxel.properties[0] > 0.0) ? prevVoxel.properties[0] : thisRay.IOF;
        float currentRefrac = (hitVoxel.color.a > 0.0 && hitVoxel.properties[0] > 0.0) ? hitVoxel.properties[0] : 1.0;

        if (abs(currentRefrac - prevRefrac) > EPS) {
            hitMapPos = mapPos;
            // O ponto de hit exato é a posição atual (que está na borda)
            hitPoint = hitEndPoint; 
            return true;
        }
    }
    
    return false;
}

// Simplified raymarch just for occlusion
bool inShadow(vec3 origin, vec3 lightDir, float maxDist) {
    vec3 rayPos = origin;
    vec3 invDir = 1.0 / (abs(lightDir) + 1e-8);
    ivec3 mapPos = ivec3(floor(rayPos));
    const float EPS = 0.0001;
    float distTraveled = 0.0;

    for (int i = 0; i < 32; ++i) {
        VoxelData vox = octreeFind(mapPos);
        
        if (vox.color.a > 0.1) return true;
        
        float sizeF = max(1.0, float(vox.size));
        int isize = int(sizeF);
        ivec3 voxelMin = (mapPos / isize) * isize;
        vec3 boxMin = vec3(voxelMin);
        vec3 boxMax = boxMin + vec3(sizeF);
        
        vec3 pickMax;
        pickMax.x = (lightDir.x > 0.0) ? boxMax.x : boxMin.x;
        pickMax.y = (lightDir.y > 0.0) ? boxMax.y : boxMin.y;
        pickMax.z = (lightDir.z > 0.0) ? boxMax.z : boxMin.z;
        vec3 tMax = (pickMax - rayPos) * invDir;
        float tStep = min(tMax.x, min(tMax.y, tMax.z));
        int axis = (tMax.x < tMax.y) ? ((tMax.x < tMax.z) ? 0 : 2) : ((tMax.y < tMax.z) ? 1 : 2);
        
        rayPos += lightDir * tStep;
        rayPos[axis] += sign(lightDir[axis]) * EPS;
        mapPos = ivec3(floor(rayPos));
        
        distTraveled += tStep;
        if (!isInsideWorld(mapPos) || distTraveled > maxDist) return false;
    }
    return false;
}

vec4 raymarching_fromDir(vec3 rayOrigin, vec3 rayDir) {
    ivec3 thisMapPos = ivec3(floor(rayOrigin));
    VoxelData thisVoxel = octreeFind(thisMapPos);

    float startIOF = (thisVoxel.properties[0] > 0.0 && thisVoxel.properties[0] < 3.0) 
                      ? thisVoxel.properties[0] : 1.0;

    Ray rayStack[MAX_RAYS];
    Ray resultRays[MAX_RAYS];
    for (int i = 0; i < MAX_RAYS; ++i) {
        rayStack[i].defined = false;
        resultRays[i].defined = false;
        resultRays[i].weight = 0.0;
        resultRays[i].colorTint = vec4(0.0);
    }

    float invLen = inversesqrt(dot(rayDir, rayDir));
    rayDir = rayDir * invLen;
    rayStack[0] = Ray(
        rayOrigin, rayDir, startIOF, 1.0, true, vec4(1.0), 0.0,
        thisVoxel.color.a > 0.0 ? thisVoxel.color : vec4(1.0),
        thisVoxel.color.a * 5.0
    );
    int stackSize = 1;
    int resultSize = 0;

    while (stackSize > 0) {
        Ray currentRay = rayStack[--stackSize];
        rayStack[stackSize].defined = false;
        
        if (!currentRay.defined) continue;

        vec3 rayStartPoint = currentRay.origin;
        ivec3 mapPos, prevMapPos;
        vec3 hitPoint, hitNormal;
        VoxelData lastVoxel;
        VoxelData hitVoxel;
        
        bool hit = hitMarching(currentRay, mapPos, prevMapPos, hitPoint, hitNormal, lastVoxel, hitVoxel);

        if (!hit) {
            // Apply Beer's Law and add to results
            vec4 transmittedColor = currentRay.colorTint;
            if (currentRay.distanceInMedium > 1e-6 && currentRay.mediumDensity > 0.0) {
                vec3 absorption = exp(-currentRay.mediumDensity * currentRay.distanceInMedium * 
                                      (vec3(1.0) - currentRay.mediumColor.rgb));
                transmittedColor.rgb *= absorption;
            }
            
            if (resultSize < MAX_RAYS) {
                resultRays[resultSize++] = Ray(
                    vec3(0.0), vec3(0.0), 0.0, currentRay.weight, true,
                    transmittedColor * skyColor, 0.0, vec4(0.0), 0.0
                );
            }
            continue;
        }

        // Update distance traveled through current medium
        float segmentDistance = length(hitPoint - rayStartPoint);
        currentRay.distanceInMedium += segmentDistance;

        vec4 voxelColor = hitVoxel.color;
        vec4 lastVoxelColor = lastVoxel.color;
        
        if (hitVoxel.color.a <= 0.0) hitVoxel.properties = vec3(1.0, 0.0, 0.0);
        if (lastVoxel.color.a <= 0.0) lastVoxel.properties = currentRay.IOF > 0.0 ? vec3(0.0) : vec3(1.0, 0.0, 0.0);

        vec3 normal = length(hitNormal) > 0.0 ? hitNormal : vec3(0.0, 1.0, 0.0);
        vec3 lightDir = vec3(0.3481553, 0.870388, 0.3481553);

        float ambientStrength = 0.2;
        float diff = max(dot(normal, lightDir), 0.0);
        vec3 finalLight = vec3(ambientStrength);
        
        if (!inShadow(hitPoint + normal * 1e-3, lightDir, 256.0)) {
            finalLight += vec3(diff);
        }
        
        // Determine surface color based on which side we're hitting
        vec4 surfaceColor = voxelColor.a > 0.0 ? voxelColor : lastVoxelColor;
        float surfaceAlpha = surfaceColor.a;
        float refracIndex = hitVoxel.properties[0] > 0.0 ? hitVoxel.properties[0] : 1.0;
        float prevRefracIndex = lastVoxel.properties[0] > 0.0 ? lastVoxel.properties[0] : 1.0;

        vec3 incidentDir = currentRay.direction;
        vec3 n = normal;

        // Apply Beer's Law
        vec4 transmittedColor = currentRay.colorTint;
        if (currentRay.distanceInMedium > 1e-6 && currentRay.mediumDensity > 0.0) {
            vec3 absorption = exp(-currentRay.mediumDensity * currentRay.distanceInMedium * 
                                  (vec3(1.0) - currentRay.mediumColor.rgb));
            transmittedColor.rgb *= absorption;
        }

        // === TRANSPARENT/TRANSLUCENT SURFACES ===
        if (surfaceAlpha < 1) {
            float cosi = dot(incidentDir, n);
            float n1 = prevRefracIndex;
            float n2 = refracIndex;
            
            if (cosi > 0.0) {
                n = -n;
                float tmp = n1; n1 = n2; n2 = tmp;
            }
            
            float eta = n1 / n2;
            vec3 refractDir = refract(incidentDir, n, eta);
            vec3 reflectDir = reflect(incidentDir, n);

            float R0 = pow((n1 - n2) / (n1 + n2), 2.0);
            float cosTheta = max(0.0, dot(-incidentDir, n));
            float fresnel = clamp(R0 + (1.0 - R0) * pow(1.0 - cosTheta, 5.0), 0.0, 1.0);

            bool hasTIR = length(refractDir) < 0.001;
            float reflectIntensity = fresnel;
            float refractIntensity = hasTIR ? 0.0 : (1.0 - fresnel);

            // DONT WASTE ENERGY YOU SICK FUCK
            if(stackSize == MAX_RAYS || reflectIntensity <= 0.001 || refractIntensity <= 0.001){
                vec4 litSurfaceColor = vec4(surfaceColor.rgb * finalLight, 1.0);
                Ray finalRay;
                finalRay.defined = true;
                finalRay.weight = currentRay.weight;
                finalRay.colorTint = transmittedColor * litSurfaceColor;
                
                addRay(resultRays, finalRay, resultSize);
                continue;
            }

            // ---- Reflection ray ----
            if (reflectIntensity > 0.001 && stackSize < MAX_RAYS) {
                float reflectWeight = currentRay.weight * reflectIntensity;
                if (reflectWeight > 1e-4)
                    rayStack[stackSize++] = Ray(
                        hitPoint + n * 1e-4, reflectDir, n1,
                        reflectWeight, true,
                        transmittedColor, 0.0, lastVoxelColor, lastVoxelColor.a * 5.0
                    );
            }

            // ---- Refraction ray ----
            if (refractIntensity > 0.001 && stackSize < MAX_RAYS && !hasTIR) {
                rayStack[stackSize++] = Ray(
                    hitPoint - n * 1e-4, refractDir, n2,
                    currentRay.weight * refractIntensity, true,
                    transmittedColor, 0.0, voxelColor, voxelColor.a * 5.0
                );
            }
        }
        else {
            // === OPAQUE SURFACE ===
            float specularFactor = hitVoxel.properties[2];
            float diffuseFactor = 1.0 - specularFactor;

            vec4 litSurfaceColor = vec4(surfaceColor.rgb * finalLight, 1.0);

            // Diffuse component
            if (diffuseFactor > 0.01 && resultSize < MAX_RAYS) {
                Ray finalRay;
                finalRay.defined = true;
                finalRay.weight = currentRay.weight * diffuseFactor;
                finalRay.colorTint = transmittedColor * litSurfaceColor;
                
                addRay(resultRays, finalRay, resultSize);
            }

            // Specular reflection
            if (specularFactor > 0.01) {
                vec3 reflectDir = reflect(incidentDir, normal);
                float reflectWeight = currentRay.weight * specularFactor;
                if (reflectWeight > 1e-4) {
                    rayStack[stackSize++] = Ray(
                        hitPoint + normal * 1e-4, reflectDir, prevRefracIndex,
                        reflectWeight, true,
                        transmittedColor, 0.0, vec4(1.0), 0.0
                    );
                }
            }
        }
    }
    
    return accumulateColors(resultRays,resultSize);
}

void main() {
    ivec2 pixel_coords = ivec2(gl_GlobalInvocationID.xy);
    ivec2 dims = imageSize(destTex);

    if (pixel_coords.x < 0 || pixel_coords.x >= dims.x || pixel_coords.y < 0 || pixel_coords.y >= dims.y) return;

    float u = (float(pixel_coords.x) / float(dims.x)) * 2.0 - 1.0;
    float v = (float(pixel_coords.y) / float(dims.y)) * 2.0 - 1.0;

    vec4 clip = vec4(u, v, -1.0, 1.0);
    vec4 view = invProjection * clip;
    if (abs(view.w) > 1e-6) view /= view.w;
    vec3 viewDir = normalize(view.xyz);
    vec3 worldDir = normalize((invView * vec4(viewDir, 0.0)).xyz);

    vec4 finalColor = raymarching_fromDir(cameraPos.xyz, worldDir);

    if (length(finalColor.rgb) == 0.0) finalColor = skyColor;

    imageStore(destTex, pixel_coords, finalColor);
}